[{"categories":["Python语言程序设计"],"content":" 之前写了一篇文章是Python基本数据类型，主要记录了python的整数类型、浮点数类型、负数类型和常用的数值运算函数。除了基本类型，python还有组合数据类型：集合类型、序列类型、字典类型 ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"集合类型 集合（set）是集合是多个元素的无序组合。 集合类型与数学中的集合概念是一致的 集合元素之间无序，每个元素唯一，不存在相同元素 集合元素不可更改，不能是可变数据类型 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 A = {\"python\", 123, (\"python\",123)} #使用{}建立集合 \u003e\u003e\u003e{123, 'python', ('python', 123)} B = set(\"pypy123\") #使用set()建立集合 \u003e\u003e\u003e{'1', 'p', '2', '3', 'y'} 集合间操作 集合处理方法 A = {\"p\", \"y\" , 123 for item in A print(item, end=\"\" ): \u003e\u003e\u003ep123y A \u003e\u003e\u003e{'p', 123, 'y'} 集合类型应用场景 1、包含关系比较 包含关系比较 \"p\" in {\"p\", \" y\" , 123} \u003e\u003e\u003eTrue {\"p\", \"y\"} \u003e={\"p\", \"y\" , 123} \u003e\u003e\u003eFalse 2、数据去重：集合类型所有元素无重复 ls = [\"p\", \"p\", \"y\", \"y\", 123] s = set(ls) # 利用了集合无重复元素的特点 \u003e\u003e\u003e{'p', 'y', 123} lt = list(s) # 还可以将集合转换为列表 \u003e\u003e\u003e['p', 'y', 123] ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"序列类型 序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字，它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。序列类型支持反向递减序号和正向递增序号 Python有6个序列的内置类型，但最常见的是字符串、列表和元组。 序列都可以进行的操作包括索引，切片，加，乘，检查成员。 此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。 ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"序列类型通用操作符 ls = [ \"python\", 123, \".io \"] ls[::-1] \u003e\u003e\u003e['. io', 123, 'python'] s = \"python123.io\" s[::-1] \u003e\u003e\u003e'oi.321nohtyp' ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:1","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"序列类型通用函数和方法 ls = [\"python\", 123,\".io \" len(ls) \u003e\u003e\u003e3 s = \"python123.io\" max(s) \u003e\u003e\u003e'y' ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:2","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"元组 Python 的元组是序列类型的一种扩展，与列表类似，不同之处在于元组的元素不能修改。 使用小括号() 或tuple() 创建，元素间用逗号, 分隔。 可以使用或不使用小括号，函数return时就是返回一个元组类型 元组创建 creature = \"cat \", \" dog \", \"tiger\", \"human\" creature \u003e\u003e\u003e('cat', 'dog', 'tiger', 'human') color = (0x001100, \"blue\", creature) color \u003e\u003e\u003e(4352, 'blue', ('cat', 'dog', 'tiger', 'human')) 元组类型操作 元组继承序列类型的全部通用操作，元组因为创建后不能修改，因此没有特殊操作，使用或不使用小括号都行。 ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:3","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"列表 列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。 列表的数据项不需要具有相同的类型，无长度限制 列表是一种序列类型，创建后可以随意被修改 使用方括号[] 或list() 创建，元素间用逗号, 分隔 列表的创建 ls = [\"cat \", \" dog \", \"tiger\", 1024] ls \u003e\u003e\u003e['cat', 'dog', 'tiger', 1024] lt = ls lt \u003e\u003e\u003e['cat', 'dog', 'tiger', 1024] 注意：lt = ls 这条赋值语句，it并不是真正创建了一个列表，赋值仅传递引用。类似c语言的指针，lt和ls都是指向[‘cat’, ‘dog’, ‘tiger’, 1024] ，都是它的名字。 列表类型操作函数和方法 ls = [\"cat \", \" dog \", \"tiger\", 1024] ls[1:2]= [1, 2, 3, 4] \u003e\u003e\u003e['cat', 1, 2, 3, 4, 'tiger', 1024] del ls[::3] \u003e\u003e\u003e[1, 2, 4, 'tiger'] ls *2 [1, 2, 4, 'tiger', 1, 2, 4, 'tiger'] #在最后添加元素 ls = [\"cat \", \" dog \", \"tiger\", 1024] ls .append(1234) \u003e\u003e\u003e['cat', 'dog', 'tiger', 1024, 1234] #指定位置增加元素 ls.insert(3, \"human\") ['cat', 'dog', 'tiger', 'human', 1024, 1234] #元素反转 ls.reverse() [1234, 1024, 'human', 'tiger', 'dog', 'cat'] ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:4","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"序列类型应用场景 数据表示：元组和列表 1、元组用于元素不改变的应用场景，更多用于固定搭配场景 2、列表更加灵活，它是最常用的序列类型 3、最主要作用：表示一组有序数据，进而操作它们 4、如果不希望数据被程序所改变，转换成元组类型 ls = [\"cat \", \" dog \", \"tiger\", 1024] lt = tuple(ls) #转换为元组类型 lt \u003e\u003e\u003e('cat', 'dog', 'tiger', 1024) ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:5","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"字典类型 字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值(key=\u003evalue)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示： d = {key1 : value1, key2 : value2 } 键必须是唯一的，但值则不必。 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 一个简单的字典实例： dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'} dict1 = { 'abc': 456 } dict2 = { 'abc': 123, 98.6: 37 } 访问字典里的值 dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'} print (\"dict['Name']: \", dict['Name']) print (\"dict['Age']: \", dict['Age']) \u003e\u003e\u003e dict['Name']: Runoob dict['Age']: 7 ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"字典类型操作函数和方法 ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:1","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"字典类型应用场景 1、映射无处不在，键值对无处不在 2、例如：统计数据出现的次数，数据是键，次数是值 3、最主要作用：表达键值对数据，进而操作它们 4、d[key] 方式既可以索引，也可以赋值 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-08","objectID":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:2","tags":["Python语言程序设计","组合数据类型","字符串","列表","字典","元组","集合","序列"],"title":"Python组合数据类型","uri":"/py17_python%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"编程语言中，函数直接或间接调用函数本身，则该函数称为递归函数。它的定义是这样写的：一种计算过程，如果其中每一步都要用到前一步或前几步的结果，称为递归的。用递归过程定义的函数，称为递归函数，例如连加、连乘及阶乘等。凡是递归的函数，都是可计算的，即能行的。 简单来说，他有两个关键特征： 链条：计算过程存在递归链条 基例：存在一个或多个不需要再次递归的基例 要实现递归函数，要熟练的明确这两个关键的特征。 ","date":"2020-05-07","objectID":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/:0:0","tags":["Python语言程序设计","递归","链条","基例","汉诺塔"],"title":"函数递归思维","uri":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/"},{"categories":["Python语言程序设计"],"content":"递归的实现： 1、递归本身是一个函数，需要函数定义方式描述 2、函数内部，采用分支语句对输入参数进行判断 3、基例和链条，分别编写对应代码 ","date":"2020-05-07","objectID":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/:0:1","tags":["Python语言程序设计","递归","链条","基例","汉诺塔"],"title":"函数递归思维","uri":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/"},{"categories":["Python语言程序设计"],"content":"以字符串反转为例 比如我要输入一串字符“1，2，3，4，5，6，7，8，9”.我要实现的效果是输出：“9，8，7，6，5，4，3，2，1”.因此我要确定递归的两个关键特征，链条和基例。 那这个例子的链条是什么呢？ 就是将字符串的首字符移到其余字符串的最后，这样就构成了一个反转，然后再将其余字符串的首字符放到其余字符串的其余字符的后面，又构成了一次反转，知道，最后一个其余字符为一个字符，那么它将和一个空字符进行反转，这也就是最后一步，也是递归所说的基例。 def rvs(s): if s == \"\": return s else : returnrvs (s[1:])+s[0 ","date":"2020-05-07","objectID":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/:0:2","tags":["Python语言程序设计","递归","链条","基例","汉诺塔"],"title":"函数递归思维","uri":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/"},{"categories":["Python语言程序设计"],"content":"以汉诺塔为例 1、对于给定数量的圆盘，从最左侧搬运到最右侧需要多少个步骤 2、要知道如何搬运的问题，把汉诺塔的三根柱子分别抽象化为ABC，再抽象化，假如有n个圆盘，要完成最后一个步骤是不是需要把n-1个圆盘搬到B柱子，然后第n个圆盘直接搬到C（这里就可以看作和n=1的情况相同，执行n=1的步骤），n-1个圆盘从B搬到C。最终完成整个过程。 count = 0 def han(a,b,c,n): global count if n==1: print(\"{}:{}-\u003e{}\".format(count+1,a,c))#最后一步该做的事就是把A-\u003eC count += 1 else: han(a,c,b,n-1) #最后一步的前一步就是，先把A-\u003eB print(\"{}:{}-\u003e{}\".format(count+1,a,c)) count+=1 han(b,a,c,n-1) #然后再把B-\u003eC def main(): han(\"A\",\"B\",\"C\",6) print(count) main() 汉诺塔的编程体现了计算机编程的计算思维！ 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-07","objectID":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/:0:3","tags":["Python语言程序设计","递归","链条","基例","汉诺塔"],"title":"函数递归思维","uri":"/py16_%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/"},{"categories":["Python语言程序设计"],"content":"作为电子信息工程的一名学生，七段数码管可以说是很常见的了。七段数码管通常用来显示时间。今天就利用七段数码管的例子要巩固刚刚所学的函数使用方法。 要实现标题的目的，首先要了解七段数码管。要绘制图，我想到了刚开始学python时的turtle库，利用turtle函数完成绘制。 ","date":"2020-05-06","objectID":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/:0:0","tags":["Python语言程序设计","time库","Turtle库","七段数码管"],"title":"七段数码管显示当前日期","uri":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/"},{"categories":["Python语言程序设计"],"content":"基本思路 步骤1：绘制单个数字对应的数码管 步骤2：获得一串数字，绘制对应的数码管 步骤3：获得当前系统时间，绘制对应的数码管 步骤1：绘制单个数字对应的数码管 七段数码管由7个基本线条组成，不同的线条之间的组合可以表示不同的数字和字母。这样走，可以一次性走完七段。 因此只要确定在哪一条线段画笔时抬起，还是放下。就可以实现绘制。 import turtle def drawLine(draw): #绘制单段数码管 turtle.pendown() if draw else turtle.penup() turtle.fd(40) turtle.right(90) def drawDigit(digit): #根据数字绘制七段数码管 drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,6,8] else drawLine(False) turtle.left(90) drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20) ","date":"2020-05-06","objectID":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/:0:1","tags":["Python语言程序设计","time库","Turtle库","七段数码管"],"title":"七段数码管显示当前日期","uri":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/"},{"categories":["Python语言程序设计"],"content":"步骤2：获得一串数字，绘制对应的数码管 import turtle def drawLine(draw): #绘制单段数码管 turtle.pendown() if draw else turtle.penup() turtle.fd(40) turtle.right(90) def drawDigit(digit): #根据数字绘制七段数码管 drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,6,8] else drawLine(False) turtle.left(90) drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20) def drawDate(date): #获得要输出的数字 for i in date: drawDigit(eval(i)) #通过eval()函数将数字变为整数 def main(): turtle.setup(800, 350, 200, 200) turtle.penup() turtle.fd(-300) turtle.pensize(5) drawDate('20181010') turtle.hideturtle() turtle.done() main() 效果： ","date":"2020-05-06","objectID":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/:0:2","tags":["Python语言程序设计","time库","Turtle库","七段数码管"],"title":"七段数码管显示当前日期","uri":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/"},{"categories":["Python语言程序设计"],"content":"步骤3：获得当前系统时间，绘制对应的数码管 用time库获取当前时间，并用time.strftime格式化时间，约定好- = + 分别表示年月日。利用turtle.write函数，写下”年月日“这三个汉字。最后再优化一下，比如画笔之间的间隔长短，让七段数码管不在连起来，而是有段落感，更像现实中的七段数码管。再比如用turtle.pencolor改变颜色，等等 #SevenDigitsDrawV2.py import turtle, time def drawGap(): #绘制数码管间隔 turtle.penup() turtle.fd(5) def drawLine(draw): #绘制单段数码管 drawGap() turtle.pendown() if draw else turtle.penup() turtle.fd(40) drawGap() turtle.right(90) def drawDigit(d): #根据数字绘制七段数码管 drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False) drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False) drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False) drawLine(True) if d in [0,2,6,8] else drawLine(False) turtle.left(90) drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False) drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False) drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20) def drawDate(date): turtle.pencolor(\"red\") for i in date: if i == '-': turtle.write('年',font=(\"Arial\", 18, \"normal\")) turtle.pencolor(\"green\") turtle.fd(40) elif i == '=': turtle.write('月',font=(\"Arial\", 18, \"normal\")) turtle.pencolor(\"blue\") turtle.fd(40) elif i == '+': turtle.write('日',font=(\"Arial\", 18, \"normal\")) else: drawDigit(eval(i)) def main(): turtle.setup(800, 350, 200, 200) turtle.penup() turtle.fd(-350) turtle.pensize(5) # drawDate('2018-10=10+') drawDate(time.strftime('%Y-%m=%d+',time.gmtime())) turtle.hideturtle() turtle.done() main() 最终效果： 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-06","objectID":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/:0:3","tags":["Python语言程序设计","time库","Turtle库","七段数码管"],"title":"七段数码管显示当前日期","uri":"/py15_%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F/"},{"categories":["Python语言程序设计"],"content":"函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。 ","date":"2020-05-05","objectID":"/py14_python3-%E5%87%BD%E6%95%B0/:0:0","tags":["Python语言程序设计","函数","参数","函数返回值","lambda","匿名函数","模块化编程"],"title":"Python3 函数","uri":"/py14_python3-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"定义一个函数 ~函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 ~任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 ~函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 ~函数内容以冒号起始，并且缩进。 ~return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 函数定义时，所指定的参数是一种占位符，函数定义后，如果不经过调用，不会被执行，函数定义时，参数是输入、函数体是处理、结果是输出(IPO) ","date":"2020-05-05","objectID":"/py14_python3-%E5%87%BD%E6%95%B0/:0:1","tags":["Python语言程序设计","函数","参数","函数返回值","lambda","匿名函数","模块化编程"],"title":"Python3 函数","uri":"/py14_python3-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"函数调用 在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；因此，实参是通过 按值调用 传递的（其中 值 始终是对象 引用 而不是对象的值）。 当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。 ","date":"2020-05-05","objectID":"/py14_python3-%E5%87%BD%E6%95%B0/:0:2","tags":["Python语言程序设计","函数","参数","函数返回值","lambda","匿名函数","模块化编程"],"title":"Python3 函数","uri":"/py14_python3-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"参数传递 调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 **必需参数:**必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 **关键字参数：**关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 def printme( str ): \"打印任何传入的字符串\" print (str) return #调用printme函数 printme( str = \"测试\") ---------------------------- 测试 **默认参数:**调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： def printinfo( name, age = 8 ): \"打印任何传入的字符串\" print (\"名字: \", name) print (\"年龄: \", age) return #调用printinfo函数 printinfo( age=12, name=\"小明\" ) print (\"************\") printinfo( name=\"小明\" ) __________________________________________________ 名字: 小明 年龄: 12 ************ 名字: 小明 年龄: 8 不定长参数 像max（x,y,z,…）这种不确定参数的函数，经常会使用到。 1、加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 def printinfo( arg1, *vartuple ): \"打印任何传入的参数\" print (\"输出: \") print (arg1) print (vartuple) # 调用printinfo 函数 printinfo( 70, 60, 50 ) —————————————————————————————— 输出: 70 (60, 50) 2、加了两个星号 ** 的参数会以字典的形式导入。 def printinfo( arg1, **vardict ): \"打印任何传入的参数\" print (\"输出: \") print (arg1) print (vardict) # 调用printinfo 函数 printinfo(1, a=2,b=3) —————————————————————————————————— 输出: 1 {'a': 2, 'b': 3} 3、声明函数时，参数中星号 *可以单独出现，如果单独出现星号 后的参数必须用关键字传入。 \u003e\u003e\u003e def f(a,b,*,c): ... return a+b+c ... \u003e\u003e\u003e f(1,2,3) # 报错 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: f() takes 2 positional arguments but 3 were given \u003e\u003e\u003e f(1,2,c=3) # 正常 6 \u003e\u003e\u003e ","date":"2020-05-05","objectID":"/py14_python3-%E5%87%BD%E6%95%B0/:0:3","tags":["Python语言程序设计","函数","参数","函数返回值","lambda","匿名函数","模块化编程"],"title":"Python3 函数","uri":"/py14_python3-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"函数返回值 1、return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。 2、return可以传递0个返回值，也可以传递任意多个返回值 3、即使没有 return 语句的函数也会返回一个值，尽管它是一个相当无聊的值。这个值称为 None （它是内置名称）。一般来说解释器不会打印出单独的返回值 None ，如果真想看到它，可以使用 print()。 def fact(n, m=1) : s = 1 for i inrange(1, n+1): s *= i return s//m, n, m ———————————————————————————— \u003e\u003e\u003efact( 10, 5 ) (725760, 10, 5) \u003e\u003e\u003ea,b,c= fact(10 ,5) print(a,b,c) 725760 10 5 ","date":"2020-05-05","objectID":"/py14_python3-%E5%87%BD%E6%95%B0/:0:4","tags":["Python语言程序设计","函数","参数","函数返回值","lambda","匿名函数","模块化编程"],"title":"Python3 函数","uri":"/py14_python3-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"匿名函数 python 使用 lambda 来创建匿名函数。 —所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 —lambda 只是一个表达式，函数体比 def 简单很多。 —lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 —lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 —虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 \u003c函数名\u003e=lambda\u003c参数\u003e:\u003c表达式\u003e 例如： f = lambdax, y : x + y f(10, 15) 输出：25 —————————————————————————— f = lambda: \"lambda函数\" print(f()) 输出：lambda函数 lambda函数主要用作一些特定函数或方法的参数，lambda函数有一些固定使用方式，一般情况，建议使用def定义的普通函数。 ","date":"2020-05-05","objectID":"/py14_python3-%E5%87%BD%E6%95%B0/:0:5","tags":["Python语言程序设计","函数","参数","函数返回值","lambda","匿名函数","模块化编程"],"title":"Python3 函数","uri":"/py14_python3-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"强制位置参数 Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。 在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参: def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) 正确使用方法： f(10, 20, 30, d=40, e=50, f=60) 以下使用方法会发生错误: f(10, b=20, c=30, d=40, e=50, f=60) # b 不能使用关键字参数的形式 f(10, 20, 30, 40, 50, f=60) # e 必须使用关键字参数的形式 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-05","objectID":"/py14_python3-%E5%87%BD%E6%95%B0/:0:6","tags":["Python语言程序设计","函数","参数","函数返回值","lambda","匿名函数","模块化编程"],"title":"Python3 函数","uri":"/py14_python3-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"蒙特卡罗方法是一种计算方法。原理是通过大量随机样本，去了解一个系统，进而得到所要计算的值。 ","date":"2020-05-04","objectID":"/py13_%E5%88%A9%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/:0:0","tags":["Python语言程序设计","圆周率","蒙特卡罗","random库","概率"],"title":"利用蒙特卡罗方法计算圆周率","uri":"/py13_%E5%88%A9%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/"},{"categories":["Python语言程序设计"],"content":"圆周率的标准公式 在讲蒙特卡罗方法之前，先了解一下圆周率的近似计算公式。 #CalPiV1.py pi = 0 N = 1000 for k in range(N): pi += 1/pow(16,k)*( \\ 4/(8*k+1) - 2/(8*k+4) - \\ 1/(8*k+5) - 1/(8*k+6) ) print(\"圆周率值是: {}\".format(pi)) 结果 圆周率值是: 3.141592653589793 ","date":"2020-05-04","objectID":"/py13_%E5%88%A9%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/:0:1","tags":["Python语言程序设计","圆周率","蒙特卡罗","random库","概率"],"title":"利用蒙特卡罗方法计算圆周率","uri":"/py13_%E5%88%A9%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/"},{"categories":["Python语言程序设计"],"content":"蒙特卡罗方法计算 蒙特卡罗方法是一种计算方法。原理是通过大量随机样本，去了解一个系统，进而得到所要计算的值。 它非常强大和灵活，又相当简单易懂，很容易实现。对于许多问题来说，它往往是最简单的计算方法，有时甚至是唯一可行的方法。 它诞生于上个世纪40年代美国的\"曼哈顿计划”，名字来源于赌城蒙特卡罗，象征概率。 对于圆周率的计算，在一个正方形内部，随机产生10000个点（即10000个坐标对 (x, y)），计算它们与中心点的距离，从而判断是否落在圆的内部。 如果这些点均匀分布，那么圆内的点应该占到所有点的 π/4，因此将这个比值乘以4，就是π的值。 下面通过python来实现 from random import random from time import perf_counter #调用time库计时函数 DARTS = 10000*10000 #抛洒点的总数量，数值越大运算越久 hits = 0.0 #抛进圆内的点个数 start = perf_counter() #开始时间 for i in range(1,DARTS+1): #循环遍历，从1开始到DARTS+1 x, y =random(),random() #抛点，利用随机数参数xy轴，0-1之间 dist = pow(x **2 + y **2,0.5) #判断点是否在圆内的关键，这里是求点到圆心的距离 if dist \u003c=1.0: #如果点到圆心距离小于1，则hits命中加一 hits+=1 pi = 4*(hits/DARTS) #命中数除于总数，再乘于四就是Π了 print(\"圆周率值是：{}\".format(pi)) print(\"运行时间是：{:.5f}\".format(perf_counter()-start))#结束时间-起始时间=实际运算时间 DARTS 的值越大，运算时间越长 圆周率值是：3.14171636 运行时间是：133.30979 蒙特卡罗方法应用的范围非常广泛。以后有机会再去深入学习。 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-04","objectID":"/py13_%E5%88%A9%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/:0:2","tags":["Python语言程序设计","圆周率","蒙特卡罗","random库","概率"],"title":"利用蒙特卡罗方法计算圆周率","uri":"/py13_%E5%88%A9%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/"},{"categories":["Python语言程序设计"],"content":" random库是使用随机数的Python标准库 -伪随机数: 采用梅森旋转算法生成的(伪)随机序列中元素 -random库主要用于生成随机数 -使用random库: importrandom 常用的有八个函数 基本随机数函数：seed(),random() 扩展随机数函数：randint(), getrandbits(), uniform(), randrange(), choice(), shuffle() 实例： import random # 生成第一个随机数 print \"random() : \", random.random() # 生成第二个随机数 print \"random() : \", random.random() random() : 0.281954791393 random() : 0.309090465205 import random import string # 随机整数： print random.randint(1,50) # 随机选取0到100间的偶数： print random.randrange(0, 101, 2) # 随机浮点数： print random.random() print random.uniform(1, 10) # 随机字符： print random.choice('abcdefghijklmnopqrstuvwxyz!@#$%^\u0026*()') # 多个字符中生成指定数量的随机字符： print random.sample('zyxwvutsrqponmlkjihgfedcba',5) # 从a-zA-Z0-9生成指定数量的随机字符： ran_str = ''.join(random.sample(string.ascii_letters + string.digits, 8)) print ran_str # 多个字符中选取指定数量的字符组成新字符串： print ''.join(random.sample(['z','y','x','w','v','u','t','s','r','q','p','o','n','m','l','k','j','i','h','g','f','e','d','c','b','a'], 5)) # 随机选取字符串： print random.choice(['剪刀', '石头', '布']) # 打乱排序 items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] print random.shuffle(items) 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-03","objectID":"/py12_random-%E5%87%BD%E6%95%B0/:0:0","tags":["Python语言程序设计","标准库","random库","随机函数"],"title":"random() 函数","uri":"/py12_random-%E5%87%BD%E6%95%B0/"},{"categories":["Python语言程序设计"],"content":"分支结构 1、对于二分支结构，除了常用的if\u003c条件\u003e：\u003c执行的语句\u003e这种结构之外，还有一种紧凑型结构。\u003c表达式1\u003e if\u003c条件\u003e else\u003c表达式2\u003e guess = eval(input()) print(\"猜{}了\".format(\"对\"ifguess==99 else \"错\" ) 2、对于多分支结构的代码编写时，需要注意多条件之间的包含关系，变量取值范围的覆盖。 3、在python中，除了常用的条件判断操作符之外，还有三个比较容易理解的保留字，and、or、not 4异常处理，如果程序异常，比如要求输入的是一个数字，但用户输入了一个字母，程序就会产生异常，这时候就需要程序进行异常处理，在python中提供了try except这种方式，当try下面的语句出现了异常，就会执行except下的语句，如第一种方式，如果采用的是第二种方式，则指定了必须由这种异常产生才会执行except下的语句。finally对应的语块4一定会执行，else对应的语块3在不发生异常时执行。 第一种方式： try: \u003c语句块1\u003e except : \u003c语句块2\u003e 第二种方式： try: \u003c语句块1\u003e except \u003c异常类型\u003e: \u003c语句块2\u003e else： \u003c语句块3\u003e finally： \u003c语句块4\u003e ","date":"2020-05-02","objectID":"/py11_%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/:0:1","tags":["Python语言程序设计","分支结构","循环结构","if","else","elif","while","break","continue"],"title":"分支结构和循环结构的一些学习总结","uri":"/py11_%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["Python语言程序设计"],"content":"循环结构 1、遍历循环 for in for i in range(N): \u003c语句块\u003e 遍历由range()函数产生的数字序列，产生循环。range(\u003c起始\u003e，\u003c结束\u003e，\u003c步长\u003e) 遍历循环还可以应用到字符串、列表、文件等等。 2、无限循环while 反复执行语句块，直到条件不满足时结束 while \u003c条件\u003e： \u003c语句\u003e 循环控制保留字 -break跳出并结束当前整个循环，执行循环后的语句 -continue结束当次循环，继续执行后续次数循环 -break和continue可以与for和while循环搭配使用 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-02","objectID":"/py11_%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/:0:2","tags":["Python语言程序设计","分支结构","循环结构","if","else","elif","while","break","continue"],"title":"分支结构和循环结构的一些学习总结","uri":"/py11_%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"categories":["Python语言程序设计"],"content":" 文本进度条 简单的开始 #TextProBarV1.py import time scale = 10 print(\"------执行开始------\") for i in range(scale+1): a = '*' * i b = '.' * (scale - i) c = (i/scale)*100 print(\"{:^3.0f}%[{}-\u003e{}]\".format(c,a,b)) time.sleep(0.1) print(\"------执行结束------\") 文本进度条 单行动态刷新 #TextProBarV2.py import time for i in range(101): print(\"\\r{:3}%\".format(i), end=\"\") time.sleep(0.1) 文本进度条 实例完整效果 #TextProBarV3.py import time scale = 50 print(\"执行开始\".center(scale//2, \"-\")) start = time.perf_counter() for i in range(scale+1): a = '*' * i b = '.' * (scale - i) c = (i/scale)*100 dur = time.perf_counter() - start print(\"\\r{:^3.0f}%[{}-\u003e{}]{:.2f}s\".format(c,a,b,dur),end='') time.sleep(0.1) print(\"\\n\"+\"执行结束\".center(scale//2,'-')) 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-05-01","objectID":"/py10_-%E4%BD%BF%E7%94%A8timesleep%E6%A8%A1%E6%8B%9F%E6%96%87%E6%9C%AC%E8%BF%9B%E5%BA%A6%E6%9D%A1/:0:0","tags":["Python语言程序设计","time库","程序计时","文本进度条"],"title":"使用timesleep()模拟文本进度条","uri":"/py10_-%E4%BD%BF%E7%94%A8timesleep%E6%A8%A1%E6%8B%9F%E6%96%87%E6%9C%AC%E8%BF%9B%E5%BA%A6%E6%9D%A1/"},{"categories":["Python语言程序设计"],"content":" 终于学到time库了，我之前学Linux时已经吃透了，所以学习python的time库毫无压力。无非是复习之前的知识而已。但博文还是要写的，毕竟记录的东西，不写以后忘了就难受了。 ","date":"2020-04-30","objectID":"/py9_time%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["Python语言程序设计","标准库","time库","时间获取","时间格式化","程序计时"],"title":"time库的使用","uri":"/py9_time%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["Python语言程序设计"],"content":"time的起始 利用time.time()可以获取一长串的浮点数，这一串浮点数就是从1970年1月1日0时0分0秒开始算起的。很多编程语言起源于UNIX系统，而UNIX系统认为1970年1月1日0点是时间纪元，所以我们常说的UNIX时间戳是以1970年1月1日0点为计时起点时间的。 最初计算机操作系统是32位，而时间也是用32位表示。 Integer在JAVA内用32位表示，因此32位能表示的最大值是2147483647。另外1年365天的总秒数是31536000，2147483647/31536000 = 68.1，也就是说32位能表示的最长时间是68年，从1970年开始的话，加上68.1，实际最终到2038年01月19日03时14分07秒，便会到达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000，算下来也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。 到这里，我想问题的答案已经显现出来了，那就是:因为用32位来表示时间的最大间隔是68年，而最早出现的UNIX操作系统考虑到计算机产生的年代和应用的时限综合取了1970年1月1日作为UNIX TIME的纪元时间(开始时间)，至于时间回归的现象相信随着64为操作系统的产生逐渐得到解决，因为用64位操作系统可以表示到292,277,026,596年12月4日15时30分08秒，相信我们的N代子孙，哪怕地球毁灭那天都不用愁不够用了，因为这个时间已经是千亿年以后了。 ","date":"2020-04-30","objectID":"/py9_time%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/:0:1","tags":["Python语言程序设计","标准库","time库","时间获取","时间格式化","程序计时"],"title":"time库的使用","uri":"/py9_time%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["Python语言程序设计"],"content":"time函数 这里就主要记录一下常用的几个函数 -时间获取：time() ctime() gmtime() -时间格式化：strftime() strptime() -程序计时：sleep(), perf_counter() 时间获取 time() 获取当前时间戳，即计算机内部时间值，浮点数 \u003e\u003e\u003etime.time() \u003e1516939876.6022282 ctime() 获取当前时间并以易读方式表示，返回字符串 \u003e\u003e\u003etime.ctime() \u003e'Fri Jan 26 12:11:16 2019' gmtime() 获取当前时间，表示为计算机可处理的时间格式 \u003e\u003e\u003etime.gmtime() time.struct_time(tm_year=2019,tm_mon=1,tm_mday=26,tm_hour=4, tm_min=11,tm_sec=16,tm_wday=4,tm_yday=26,tm_isdst=0) 时间格式化 格式化：类似字符串格式化，需要有展示模板，展示模板由特定的格式化控制符组成 strftime(tpl, ts )是个模板函数。需要什么样的输出格式用户可以自定义 strftime(tpl, ts ) tpl是格式化模板字符串，用来定义输出效果ts是计算机内部时间类型变量 \u003e\u003e\u003et = time.gmtime() \u003e\u003e\u003etime.strftime(\"%Y -%m-%d%H:%M:%S\",t) \u003e'2018-01 -26 12:55:20 把字符串变成计算机内部可以操作的时间。与strftime(）互补 strptime(str, tpl) str是字符串形式的时间值tpl是格式化模板字符串，用来定义输入效果 \u003e\u003e\u003etimeStr= '2018-01- 26 12:55:20' \u003e\u003e\u003etime.strptime(timeStr, \"%Y -%m -%d%H:%M:%S\") time.struct_time(tm_year=2018,tm_mon=1,tm_mday=26,tm_hour=4, tm_min=11,tm_sec=16,tm_wday=4,tm_yday=26,tm_isdst=0) 他们之间的关系 程序计时 perf_counter() 返回一个CPU级别的精确时间计数值，单位为秒由于这个计数值起点不确定，连续调用差值才有意义 \u003e\u003e\u003estart = time.perf_counter() 318.66599499718114 \u003e\u003e\u003eend = time.perf_counter() 341.3905185375658 \u003e\u003eend - start 22.724523540384666 sleep(s) s拟休眠的时间，单位是秒，可以是浮点数 \u003e\u003e\u003edef wait(): time.sleep(3.3) \u003e\u003e\u003ewait() 程序将等待3.3秒后再退出 资料来源： https://docs.python.org/zh-cn/3/ 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 Python官方手册 ","date":"2020-04-30","objectID":"/py9_time%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/:0:2","tags":["Python语言程序设计","标准库","time库","时间获取","时间格式化","程序计时"],"title":"time库的使用","uri":"/py9_time%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["Python语言程序设计"],"content":" 字符串 字符串是 Python 中最常用的数据类型。是由0个或多个字符组成的有序字符序列，我们可以使用引号( ' 或 \" )来创建单行字符串，由一对三单引号或三双引号表示，可表示多行字符串。 问：三引号不是多行注释吗？ 答：其实在python中并没有规定三引号是多行注释。在python中，如果字符串没有被赋值，程序是不会执行的，三引号的多行注释，本质上还是字符串。 ","date":"2020-04-29","objectID":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["Python语言程序设计","数据类型","字符串"],"title":"Python3 字符串","uri":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python语言程序设计"],"content":"字符串的顺序 字符串是由0个或多个字符组成的有序字符序列，他的第一个字符串序号为0. ","date":"2020-04-29","objectID":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:1","tags":["Python语言程序设计","数据类型","字符串"],"title":"Python3 字符串","uri":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python语言程序设计"],"content":"字符串的使用 索引 使用[ ]获取字符串中一个或多个字符 索引：返回字符串中单个字符\u003c字符串\u003e[M] 12345678”[0] 或 number[-1] number = \"12345678\" print(\"12345678\"[0]) print(number[-1]) \u003e\u003e\u003e1 \u003e8 切片 -切片：返回字符串中一段字符子串\u003c字符串\u003e[M: N] “12345678”[1:3] 或 number[1:3] number = \"12345678\" print(\"12345678\"[1:3]) print(number[1:3]) \u003e\u003e\u003e23 \u003e23 切片的高级用法 \u003c字符串\u003e[M: N: K]，M缺失表示至开头，N缺失表示至结尾，根据步长K对字符串切片 \"〇一二三四五六七八九十\"[1:8:2] \u003e\u003e\u003e\"一三五七\" \"〇一二三四五六七八九十\"[::-1] \u003e\u003e\u003e\"十九八七六五四三二一〇\" 拼接 可以截取字符串的一部分并与其他字段拼接，如下实例： 例一： var1 = 'Hello World!' print (\"已更新字符串 : \", var1[:] + 'python!') \u003e\u003e\u003e已更新字符串 : Hello World!python! 例二： var1 = 'Hello World!' print (\"已更新字符串 : \", var1[:6] + 'python!') \u003e\u003e\u003e已更新字符串 : Hello python! ","date":"2020-04-29","objectID":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:2","tags":["Python语言程序设计","数据类型","字符串"],"title":"Python3 字符串","uri":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python语言程序设计"],"content":"转义符 转义符表达特定字符的本意,在需要在字符中使用特殊字符时，python用反斜杠()转义字符。如下表： | 转义字符 | 描述 | | ———– | ———————————————————— | | (在行尾时) | 续行符 | | \\ | 反斜杠符号 | | ' | 单引号 | | \" | 双引号 | | \\a | 响铃 | | \\b | 退格(Backspace) | | \\000 | 空 | | \\n | 换行 | | \\v | 纵向制表符 | | \\t | 横向制表符 | | \\r | 回车 | | \\f | 换页 | | \\oyy | 八进制数，yy 代表的字符，例如：\\o12 代表换行，其中 o 是字母，不是数字 0。 | | \\xyy | 十六进制数，yy代表的字符，例如：\\x0a代表换行 | | \\other | 其它的字符以普通格式输出 | ","date":"2020-04-29","objectID":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:3","tags":["Python语言程序设计","数据类型","字符串"],"title":"Python3 字符串","uri":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python语言程序设计"],"content":"Python字符串运算符 下表实例变量a值为字符串 “Hello”，b变量值为 “Python”： | 操作符 | 描述 | 实例 | | —— | ———————————————————— | ——————————— | | + | 字符串连接 | a + b 输出结果： HelloPython | | * | 重复输出字符串 | a*2 输出结果：HelloHello | | [] | 通过索引获取字符串中字符 | a[1] 输出结果 e | | [ : ] | 截取字符串中的一部分，遵循左闭右开原则，str[0:2] 是不包含第 3 个字符的。 | a[1:4] 输出结果 ell | | in | 成员运算符 - 如果字符串中包含给定的字符返回 True | ‘H’ in a 输出结果 True | | not in | 成员运算符 - 如果字符串中不包含给定的字符返回 True | ‘M’ not in a 输出结果 True | | r/R | 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 | print( r’\\n’) print( R’\\n’ ) | | % | 格式字符串 | 如下面的例子 | ","date":"2020-04-29","objectID":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:4","tags":["Python语言程序设计","数据类型","字符串"],"title":"Python3 字符串","uri":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python语言程序设计"],"content":"Python字符串格式化 Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。 在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。 print (\"我叫 %s今年 %d岁!\" % ('小明', 12)) \u003e\u003e\u003e我叫 小明 今年 12 岁! python字符串格式化符号: | 符 号 | 描述 | | —— | :———————————– | | %c | 格式化字符及其ASCII码 | | %s | 格式化字符串 | | %d | 格式化整数 | | %u | 格式化无符号整型 | | %o | 格式化无符号八进制数 | | %x | 格式化无符号十六进制数 | | %X | 格式化无符号十六进制数（大写） | | %f | 格式化浮点数字，可指定小数点后的精度 | | %e | 用科学计数法格式化浮点数 | | %E | 作用同%e，用科学计数法格式化浮点数 | | %g | %f和%e的简写 | | %G | %f 和 %E 的简写 | | %p | 用十六进制数格式化变量的地址 | 格式化操作符辅助指令: | 符号 | 功能 | | —– | :———————————————————– | | * | 定义宽度或者小数点精度 | | - | 用做左对齐 | | + | 在正数前面显示加号( + ) | | | 在正数前面显示空格 | | # | 在八进制数前面显示零(‘0’)，在十六进制前面显示'0x’或者'0X’(取决于用的是’x’还是’X’) | | 0 | 显示的数字前面填充'0’而不是默认的空格 | | % | ‘%%‘输出一个单一的’%’ | | (var) | 映射变量(字典参数) | | m.n. | m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) | capitalize() 将字符串的第一个字符转换为大写 center(width, fillchar) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 bytes.decode(encoding=\"utf-8\", errors=\"strict\") Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 encode(encoding='UTF-8',errors='strict') 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常. isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 len(string) 返回字符串长度 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 lower() 转换字符串中所有大写字符为小写. lstrip() 截掉字符串左边的空格或指定字符。 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 replace(old, new [, max]) 把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. rindex( str, beg=0, end=len(string)) 类似于 index()，不过是从右边开始. rjust(width,[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 rstrip() 删除字符串字符串末尾的空格. split(str=\"\", num=string.count(str)) num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串 splitlines([keepends]) 按照行('\\r', '\\r\\n', \\n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 startswith(substr, beg=0,end=len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 strip([chars]) 在字符串上执行 lstrip()和 rstrip() swapcase() 将字符串中大写转换为小写，小写转换为大写 title() 返回\"标题化\"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) translate(table, deletechars=\"\") 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 upper() 转换字符串中的小写字母为大写 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 ","date":"2020-04-29","objectID":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:5","tags":["Python语言程序设计","数据类型","字符串"],"title":"Python3 字符串","uri":"/py8_python3-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python语言程序设计"],"content":"经过这几天的学习，我想用Python编程的思想去思考一下，每天进步一点点和每天退步一点点的问题。 ","date":"2020-04-28","objectID":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/:0:0","tags":["Python语言程序设计","天天向上"],"title":"每天努力一点点和每天退步一点点的思考","uri":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Python语言程序设计"],"content":"问题一 如果每天在原来的基础上进步千分之一，那么一年365天我们进步了多少？那如果每天退步千分之一，那又是多少？他们相差多少？ dayup = 0.001 daydown = 0.001 up = pow(1+dayup, 365) dowm = pow(1-daydown, 365) disparity = round(up/dowm,1) print(\"每天进步千分之一，一年后是：{0:.2f}\\n\" \"每天退步千分之一，一年后是：{1:.2f}\\n\" \"他们之间的差距：{2:.2f}\\n\".format(up,dowm,disparity)) 输出 每天进步千分之一，一年后是：1.44 每天退步千分之一，一年后是：0.69 他们之间的差距：2.10 总结：在上面的代码中，使用到了两个数学函数，分别是pow（a，b），它的作用跟数学上的a^b（a的b次方）是一致的,另一个是round（\u003c浮点数\u003e，\u003c数值\u003e），作用是去除尾数，保留n位小数。有人说它是四舍五入的方式保留小数，其实是不对的，准确来说它采用了 四舍六入五成双的方式。原理以后再深入。 ","date":"2020-04-28","objectID":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/:0:1","tags":["Python语言程序设计","天天向上"],"title":"每天努力一点点和每天退步一点点的思考","uri":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Python语言程序设计"],"content":"问题二 如果每天在原来的基础上进步百分之一，那么一年365天我们进步了多少？那如果每天退步百分之一，那又是多少？他们相差多少？ dayup = 0.01 daydown = 0.01 up = pow(1+dayup, 365) dowm = pow(1-daydown, 365) disparity = round(up/dowm,1) print(\"每天进步百分之一，一年后是：{0:.2f}\\n\" \"每天退步百分之一，一年后是：{1:.2f}\\n\" \"他们之间的差距:{2:.2f}\\n\".format(up,dowm,disparity)) 输出 每天进步百分之一，一年后是：37.78 每天退步百分之一，一年后是：0.03 他们之间的差距:1480.70 总结：看到这个结果，实在是太恐怖了，坚持的力量远比我想象中的要大得多的多。 问题二中，没什么新的内容，需要注意的是print输出格式，字符串的格式化输出，用槽{ }引出，{\u003c这里是序号\u003e：.2f}，用.format（）引出。 ","date":"2020-04-28","objectID":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/:0:2","tags":["Python语言程序设计","天天向上"],"title":"每天努力一点点和每天退步一点点的思考","uri":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Python语言程序设计"],"content":"问题三 如果一年365天，我们工作日的时候进步1%，双休日的时候退步1%。一年后会发生什么？ up = 1.0 dayup = input(\"请输入进步的程度（格式为：\u003c数字\u003e%）：\\n\") daydown = input(\"请输入退步的程度（格式为：\u003c数字\u003e%）：\\n\") for i in range(365): if i % 7 in [6,0]: #假设6代表星期6，0代表星期天 up = up*(1-(eval(daydown[:-1])) / 100) else: up = up*(1+(eval(dayup[:-1])) / 100) print(\"一年后：{0:.2f}\\n\".format(up)) 输出 请输入进步的程度（格式为：\u003c数字\u003e%）： 1% 请输入退步的程度（格式为：\u003c数字\u003e%）： 1% 一年后：4.63 总结：可以看到，不间断的进步1%一年后是：37.78。而工作日努力，双休日休息退步的话，一年后是4.63，差距还是没非常大的。 问题三中，复习了字符串的切片操作，在输入进退步的程度时，故意多加了一个百分号，目的是为了让自己更熟悉字符串切片操作，并不是画蛇添足。有意思的是，刚开始我忘了输入进来的是字符串，运行总会出错，后来才发现字符串是不能运算的，必须使用eval（）将最外层的引号去除。这点跟c语言有很大的不同。在这段代码中，还利用了循环语句for i in range（）。分支判断语句if i in [] 和if else。（要注意的是，在最后要记得加：冒号） ","date":"2020-04-28","objectID":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/:0:3","tags":["Python语言程序设计","天天向上"],"title":"每天努力一点点和每天退步一点点的思考","uri":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Python语言程序设计"],"content":"问题四 那如果一年365天，我三天打鱼两天晒网，我打鱼的时候进步1%，我晒网的时候退步2%，情况又会是如何？ up = 1.0 a= 0 b = 0 day = input(\"请输入一个完整的周期：\\n\") upday = input(\"请输入一个周期内努力的天数：\\n\") dayup = input(\"请输入努力的程度（格式为：\u003c数字\u003e%）：\\n\") daydown = input(\"请输入颓废的程度（格式为：\u003c数字\u003e%）：\\n\") for i in range(365): if (i % eval(day)) \u003e= eval(upday): up = up*(1-(eval(daydown[:-1])) / 100) a+=1 else: up = up*(1+(eval(dayup[:-1])) / 100) b+=1 print(\"一年后：{0:.2f}\\n\" \"你努力了%d天\\n\" \"你颓废了%d天\\n\".format(up) %(b,a)) 请输入一个完整的周期： 5 请输入一个周期内努力的天数： 3 请输入努力的程度（格式为：\u003c数字\u003e%）： 1% 请输入颓废的程度（格式为：\u003c数字\u003e%）： 2% 一年后：0.46 你努力了219天 你颓废了146天 **总结：**问题四 if (i % eval(day)) \u003e= eval(upday):这条语句要注意，刚开始我花了很多时间去看错误在哪，原来是我的逻辑没有弄清楚，写了大于号，导致结果不对，这里考的是数学思维。 ","date":"2020-04-28","objectID":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/:0:4","tags":["Python语言程序设计","天天向上"],"title":"每天努力一点点和每天退步一点点的思考","uri":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Python语言程序设计"],"content":"问题五 一年360天，如果A君每天进步1%，B君工作5天，休息两天，休息时退步1%。C君工作3天，休息两天，休息时退步0.5%.请问B君和C君在工作时至少需要多大的努力才能比A君一年的进步要大？ 解答：在编程前要先在脑海里有一个思维导图，就好像A君和B君比较，设B君的努力程度dayfactorB为X，如果B君比不过A君，则dayfactorB+ 0.001后再传入函数daydayupB里进行计算365天的成长值，返回成长值dayupB，与A君的成长值dayupA再进行比较，利用while函数如此循环反复，直至B君的成长值dayupB超过A君的成长值后，输出结果。C君的原理也是一样的，就不多赘述了。 def daydayupB(df): dayupB = 1.0 for i in range(365): if i % 7 in [6,0]: #假设6为星期六，0为星期天 dayupB = dayupB*(1 - 0.01) #退步1% else: dayupB = dayupB*(1 + df) return dayupB def daydayupC(df): dayupC = 1.0 for i in range(365): if i % 5 in [4,0]: #假设4,0时休息日 dayupC = dayupC*(1 - 0.005) #退步0.5% else: dayupC = dayupC*(1 + df) return dayupC dayfactorB = 0.01 dayfactorC = 0.01 dayupA = pow(1.01,365) #A君365每天进步1% print(dayupA) while daydayupB(dayfactorB) \u003c dayupA: dayfactorB += 0.001 print(\"B需要用：{:.3f}\".format(dayfactorB)) while daydayupC(dayfactorC) \u003c dayupA: dayfactorC += 0.001 print(\"C需要用:{:.3f}\".format(dayfactorC)) 37.78343433288728 B需要用：0.019 C需要用:0.021 总结：问题五中，第一次接触到python的def函数概念，其实跟其它语言也是类似，传递参数等等，但深入的我还没去了解，不过这里解锁了两个关键字def和while。也是很开心的。 ","date":"2020-04-28","objectID":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/:0:5","tags":["Python语言程序设计","天天向上"],"title":"每天努力一点点和每天退步一点点的思考","uri":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Python语言程序设计"],"content":"大总结 虽然是短短的几行代码，但包含了很多的语法元素。条件循环、计数循环、分支、函数、计算思维。 通过这个问题的讨论分析，也可知道，坚持的力量不容小觑。进步是指数型上涨的，不进则退也是这个道理。 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 ","date":"2020-04-28","objectID":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/:0:6","tags":["Python语言程序设计","天天向上"],"title":"每天努力一点点和每天退步一点点的思考","uri":"/py7_%E6%AF%8F%E5%A4%A9%E5%8A%AA%E5%8A%9B%E4%B8%80%E7%82%B9%E7%82%B9%E5%92%8C%E6%AF%8F%E5%A4%A9%E9%80%80%E6%AD%A5%E4%B8%80%E7%82%B9%E7%82%B9%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Python语言程序设计"],"content":" 数学函数 函数 描述 abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x \u003c y 返回 -1, 如果 x == y 返回 0, 如果 x \u003e y 返回 1。 Python 3 已废弃，使用 (x\u003ey)-(x\u003cy) 替换。 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) 返回数字x的平方根。 随机数函数 随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。Python包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 三角函数 Python包括以下三角函数： | 函数 | 描述 | | ———– | ————————————————- | | acos(x) | 返回x的反余弦弧度值。 | | asin(x) | 返回x的反正弦弧度值。 | | atan(x) | 返回x的反正切弧度值。 | | atan2(y, x) | 返回给定的 X 及 Y 坐标值的反正切值。 | | cos(x) | 返回x的弧度的余弦值。 | | hypot(x, y) | 返回欧几里德范数 sqrt(xx + yy)。 | | sin(x) | 返回的x弧度的正弦值。 | | tan(x) | 返回x弧度的正切值。 | | degrees(x) | 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 | | radians(x) | 将角度转换为弧度 | 数学常量 函数 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数） 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 Python3菜鸟教程 ","date":"2020-04-27","objectID":"/py6_-python%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0/:0:0","tags":["Python语言程序设计","数学函数","随机数函数","三角函数","数学常量"],"title":"Python中的各种数值运算函数","uri":"/py6_-python%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0/"},{"categories":["其它"],"content":"由于此博客是部署于GitHub平台的，如果打开此博客很慢，说明打开GitHub也很慢，因此寻找了一些加快打开速度的方法 方法一：改hosts文件（简单有效） 1、用文本编辑器打开 C:\\Windows\\System32\\drivers\\etc 一个名叫hosts的文件（无后缀） 在底下加入两行神秘代码，保持即可 78.16.49.15 github.global.ssl.fastly.net 185.199.111.153 assets-cdn.github.com 当然，红框框的那些东西有时候会失效的，但只要登录 http://mtool.chinaz.com/dns/?host=assets-cdn.github.com\u0026ip=\u0026accessmode=1 或 http://tool.chinaz.com/dns/?type=1\u0026host=github.global.ssl.fastly.net\u0026ip= 这两个网站，搜索 assets-cdn.github.com 和 github.global.ssl.fastly.net 这两个网址，寻找TTL最小的那个复制，替换红框框的就行了 方法二：科学上网（简单粗暴） 备用机场： https://www.wujievpn.xyz/ https://jianguo01.com/user ","date":"2020-04-26","objectID":"/%E5%A6%82%E4%BD%95%E5%8A%A0%E9%80%9F%E8%BF%9B%E5%85%A5%E5%8D%9A%E5%AE%A2%E9%80%9F%E5%BA%A6/:0:0","tags":["其它","GitHub"],"title":"加速打开GitHub和此博客的方法","uri":"/%E5%A6%82%E4%BD%95%E5%8A%A0%E9%80%9F%E8%BF%9B%E5%85%A5%E5%8D%9A%E5%AE%A2%E9%80%9F%E5%BA%A6/"},{"categories":["Python语言程序设计"],"content":"整数类型 整型(int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。 整数类型与数学中整数的概念一致。 整数类型4种进制表示形式 -十进制：1010, 99999, -217，1314520 -二进制，以0b或0B开头：0b010, -0B101 -八进制，以0o或0O开头：0o123, -0O456 -十六进制，以0x或0X开头：0x9a, -0X89 进制的转换函数： bin（i）：将i转换为2进制，以“0b”开头。 oct（i）：将i转换为8进制，以“0o”开头。 int（i）：将i转换为10进制，正常显示。 hex（i）：将i转换为16进制，以“0x”开头。 ","date":"2020-04-24","objectID":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","tags":["Python语言程序设计","整型(int)","浮点型(float)","复数(complex)","python常用数值运算函数"],"title":"Python基本数据类型","uri":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"浮点数类型 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250)浮点数类型与数学中实数的概念一致，带有小数点及小数的数字。 -浮点数取值范围和小数精度都存在限制，但常规计算可忽略-取值范围数量级约10^307 至10^308，精度数量级10^-16。因此浮点数间运算存在不确定尾数，它不是bug。这是由于计算机内部以二进制保存，所以十进制的有限位的小数，在计算机内部会是一个无限位的小数。 例如 十进制的0.9虽然只有一位小数，转道成2进制是无限循环小数0.1110011001100110011 0.1 + 0.2 \u003e\u003e0.30000000000000004 因此浮点数不能直接比较， 1、当浮点数进行比较时，就要加上round（）函数，消除小数点后的不确定位数。 2、round(x, d)：对x四舍五入，d是小数截取位数。 3、不确定尾数一般发生在10-16左右，round()十分有效 0.1 + 0.2 == 0.3 \u003e\u003e\u003eFalse round(0.1+0.2, 1) == 0.3 \u003e\u003e\u003eTrue 浮点数可以采用科学计数法表示 使用字母e或E作为幂的符号，以10为基数，格式如下： \u003c a \u003ee\u003c b \u003e 表示a*10^b 例如：4.3e-3值为0.0043 9.6E5值为960000.0 ","date":"2020-04-24","objectID":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:2","tags":["Python语言程序设计","整型(int)","浮点型(float)","复数(complex)","python常用数值运算函数"],"title":"Python基本数据类型","uri":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"复数类型 复数(complex) - 复数由实数部分和虚数部分构成.a+bj被称为复数，其中，a是实部，b是虚部。 复数类型与数学中复数的概念一致 z = 1.23e-4+5.6e+89j z.real获得实部 z.imag获得虚部 ","date":"2020-04-24","objectID":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:3","tags":["Python语言程序设计","整型(int)","浮点型(float)","复数(complex)","python常用数值运算函数"],"title":"Python基本数据类型","uri":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"数字类型的关系 类型间可进行混合运算，生成结果为\"最宽\"类型 三种类型存在一种逐渐\"扩展\"或\"变宽\"的关系：整数-\u003e浮点数-\u003e 复数,例如： 123 + 4.0 = 127.0 (整数+浮点数= 浮点数) ","date":"2020-04-24","objectID":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:4","tags":["Python语言程序设计","整型(int)","浮点型(float)","复数(complex)","python常用数值运算函数"],"title":"Python基本数据类型","uri":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"常用的数值运算函数 abs(x) #绝对值，x的绝对值.例如abs(-10.01) 结果为10.01 divmod(x,y)#商余，(x//y, x%y)，同时输出商和余数，例如divmod(10, 3) 结果为(3,1) pow(x, y[, z])#幂余，(x**y)%z，[..]表示参数z可省略，例如pow(3, pow(3, 99),10000) 结果为4587 round(x[, d])#四舍五入，d是保留小数位数，默认值为0，例如：round(-10.123,2) 结果为-10.12 max(x1,x2, ... ,xn)#最大值，返回x1,x2, ... ,xn中的最大值，n不限，例如：max(1, 9, 5, 4,3) 结果为9 min(x1,x2, ... ,xn)#最小值，返回x1,x2, ... ,xn中的最小值，n不限，例如：min(1, 9, 5, 4, 3) 结果为1 int(x)#将x变成整数，舍弃小数部分，例如：int(123.45) 结果为123；int(\"123\") 结果为123 float(x)#将x变成浮点数，增加小数部分，例如：float(12) 结果为12.0；float(\"1.23\") 结果为1.23 complex(x)#将x变成复数，增加虚数部分，例如：complex(4) 结果为4 + 0j 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 ","date":"2020-04-24","objectID":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:5","tags":["Python语言程序设计","整型(int)","浮点型(float)","复数(complex)","python常用数值运算函数"],"title":"Python基本数据类型","uri":"/py5_python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python语言程序设计"],"content":"Python第三方库下载时的国内镜像 国内镜像： 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ ","date":"2020-04-21","objectID":"/py19_python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%B8%8B%E8%BD%BD%E6%97%B6%E7%9A%84%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/:0:1","tags":["Python语言程序设计","镜像","第三方库"],"title":"Python第三方库下载时的国内镜像","uri":"/py19_python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%B8%8B%E8%BD%BD%E6%97%B6%E7%9A%84%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/"},{"categories":["Python语言程序设计"],"content":"使用方法 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库名 ","date":"2020-04-21","objectID":"/py19_python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%B8%8B%E8%BD%BD%E6%97%B6%E7%9A%84%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/:0:2","tags":["Python语言程序设计","镜像","第三方库"],"title":"Python第三方库下载时的国内镜像","uri":"/py19_python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E4%B8%8B%E8%BD%BD%E6%97%B6%E7%9A%84%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/"},{"categories":["Python语言程序设计"],"content":"Python的学习总是很有趣，强大的库让人欲罢不能，即使作为初学者的我来说，用代码绘图是极具诱惑力的，而Turtle库是Python语言中一个很流行的绘制图像的函数库，它的使用方法也很简答，只要我们把自己想象成一个小乌龟，在一个横轴为x、纵轴为y的坐标系原点，(0,0)位置开始，它根据一组函数指令的控制，在这个平面坐标系中移动，从而在它爬行的路径上绘制了图形。只要了解一些基本概念就可以快速上手。 ","date":"2020-04-20","objectID":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/:0:0","tags":["Python语言程序设计","Turtle库","绘图"],"title":"用Python绘图之Turtle(海龟)库详解","uri":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/"},{"categories":["Python语言程序设计"],"content":"1. 画布(canvas) 画布就是turtle为我们展开用于绘图区域，我们可以设置它的大小和初始位置。 设置画布大小 1、 turtle.screensize(canvwidth=None, canvheight=None, bg=None) 参数分别为画布的宽(单位像素), 高, 背景颜色。 如： turtle.screensize(800,600, \"green\") turtle.screensize() #返回默认大小(400, 300) 2、 turtle.setup(width=0.5, height=0.75, startx=None, starty=None) 参数：width, height: 输入宽和高为整数时, 表示像素; 为小数时, 表示占据电脑屏幕的比例，(startx, starty): 这一坐标表示矩形窗口左上角顶点的位置, 如果为空,则窗口位于屏幕中心。 如： turtle.setup(width=0.6,height=0.6) turtle.setup(width=800,height=800, startx=100, starty=100) ","date":"2020-04-20","objectID":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/:0:1","tags":["Python语言程序设计","Turtle库","绘图"],"title":"用Python绘图之Turtle(海龟)库详解","uri":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/"},{"categories":["Python语言程序设计"],"content":"2、画笔 在画布上，默认有一个坐标原点为画布中心的坐标轴，坐标原点上有一只面朝x轴正方向小乌龟。这里我们描述小乌龟时使用了两个词语：坐标原点(位置)，面朝x轴正方向(方向)， turtle绘图中，就是使用位置方向描述小乌龟(画笔)的状态。 设置画笔的宽度，单位为像素； turtle.pensize()： 2)没有参数传入，返回当前画笔颜色，传入参数设置画笔颜色，可以是字符串如\"green”, “red”,也可以是RGB 3元组。 turtle.pencolor()： 3)设置画笔移动速度，画笔绘制的速度范围[0,10]整数，数字越大越快。 turtle.speed(speed)： (1)画笔运动命令 命令 说明 turtle.forward(distance) 向当前画笔方向移动distance像素长度 turtle.backward(distance) 向当前画笔相反方向移动distance像素长度 turtle.right(degree) 顺时针移动degree° turtle.left(degree) 逆时针移动degree° turtle.pendown() 移动时绘制图形，缺省时也为绘制 turtle.goto(x,y) 将画笔移动到坐标为x,y的位置 turtle.penup() 提起笔移动，不绘制图形，用于另起一个地方绘制 turtle.circle() 画圆，半径为正(负)，表示圆心在画笔的左边(右边)画圆 setx( ) 将当前x轴移动到指定位置 sety( ) 将当前y轴移动到指定位置 setheading(angle) 设置当前朝向为angle角度 home() 设置当前画笔位置为原点，朝向东。 dot( r ) 绘制一个指定直径和颜色的圆点 (2)画笔控制命令 命令 说明 turtle.fillcolor(colorstring) 绘制图形的填充颜色 turtle.color(color1, color2) 同时设置pencolor=color1, fillcolor=color2 turtle.filling() 返回当前是否在填充状态 turtle.begin_fill() 准备开始填充图形 turtle.end_fill() 填充完成 turtle.hideturtle() 隐藏画笔的turtle形状 turtle.showturtle() 显示画笔的turtle形状 (3)全局控制命令 命令 说明 turtle.clear() 清空turtle窗口，但是turtle的位置和状态不会改变 turtle.reset() 清空窗口，重置turtle状态为起始状态 turtle.undo() 撤销上一个turtle动作 turtle.isvisible() 返回当前turtle是否可见 stamp() 复制当前图形 turtle.write(s [,font=(“font-name”,font_size,“font_type”)]) 写文本，s为文本内容，font是字体的参数，分别为字体名称，大小和类型；font为可选项，font参数也是可选项 (4)其它 命令 说明 turtle.mainloop()或turtle.done() 启动事件循环 -调用Tkinter的mainloop函数。必须是乌龟图形程序中的最后一个语句。 turtle.mode(mode=None) 设置乌龟模式（“standard”，“logo”或“world”）并执行重置。如果没有给出模式，则返回当前模式。standard向右（东）逆时针；logo向上（北）顺时针 turtle.delay(delay=None) 设置或返回以毫秒为单位的绘图延迟。 turtle.begin_poly() 开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。 turtle.end_poly() 停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。 turtle.get_poly() 返回最后记录的多边形。 ","date":"2020-04-20","objectID":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/:0:2","tags":["Python语言程序设计","Turtle库","绘图"],"title":"用Python绘图之Turtle(海龟)库详解","uri":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/"},{"categories":["Python语言程序设计"],"content":"3、命令详解 turtle.circle(radius, extent=None, steps=None) 描述：以给定半径画圆 参数： radius(半径)：半径为正(负)，表示圆心在画笔的左边(右边)画圆； extent(弧度) (optional)； steps (optional) (做半径为radius的圆的内切正多边形，多边形边数为steps)。 举例: circle(50) # 整圆; circle(50,steps=3) # 三角形; circle(120, 180) # 半圆 #第一次用turtle画画。 import turtle a = 0 turtle.setup(800, 500) #设置宽为800高为500窗口位于屏幕中心 turtle.penup() #把笔抬起来 turtle.fd(-250) #向前移动-250个像素点（也就是后退250个像素点） turtle.pendown() #把笔放下 turtle.pensize(5) #设置笔的大小为25个像素 turtle.pencolor(\"red\")#设置笔的颜色为紫色 turtle.seth(-40) #海龟头的方向为-40° for i in range(5): #循环执行四次 turtle.circle(40, 80)#以40像素为半径（左边）绘制80度的弧度 a = a+3 #让蛇的身体慢慢变大 print(a) turtle.pensize(5 + a) turtle.circle(-40, 80)#以40像素为半（右边）径绘制80度的弧度 a = a+3 print(a) turtle.pensize(5 + a) turtle.seth(0) #将龟头调整到零度，也就是向X轴正方向 turtle.fd(50) #前进50个像素 turtle.circle(30, 180) #以像素30为半径向此时龟头方向以左的方向绘制180度弧形 turtle.pensize(40) #画笔变大 turtle.fd(40) #前进40个像素 turtle.pensize(7) #画笔变小 turtle.fd(30) #前进30像素 turtle.pensize(4) #画笔大小为4像素 turtle.circle(15,60) #画弧 turtle.circle(15,-60) #画弧，返回 turtle.circle(-15,60) #画弧 turtle.circle(-15,-60) #画弧，返回 turtle.backward(40) #后退40 turtle.seth(90) #龟头方向调整为90 turtle.fd(10) #前进10 turtle.pencolor(\"black\") #改变颜色为黑 turtle.circle(5) #画眼睛 turtle.penup() #抬起笔 turtle.backward(20) #后退20 turtle.pendown() #放下笔 turtle.circle(5) #画眼睛 turtle.hideturtle() #隐藏乌龟 turtle.done() #保持窗口不关闭 效果如下 ‘‘后来又参考别人的代码做了个时钟。。。 # coding=utf-8 import turtle from datetime import * # 抬起画笔，向前运动一段距离放下 def Skip(step): turtle.penup() turtle.forward(step) turtle.pendown() def mkHand(name, length): # 注册Turtle形状，建立表针Turtle turtle.reset() Skip(-length * 0.1) # 开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。 turtle.begin_poly() turtle.forward(length * 1.1) # 停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。 turtle.end_poly() # 返回最后记录的多边形。 handForm = turtle.get_poly() turtle.register_shape(name, handForm) def Init(): global secHand, minHand, hurHand, printer # 重置Turtle指向北 turtle.mode(\"logo\") # 建立三个表针Turtle并初始化 mkHand(\"secHand\", 135) mkHand(\"minHand\", 125) mkHand(\"hurHand\", 90) secHand = turtle.Turtle() secHand.shape(\"secHand\") minHand = turtle.Turtle() minHand.shape(\"minHand\") hurHand = turtle.Turtle() hurHand.shape(\"hurHand\") for hand in secHand, minHand, hurHand: hand.shapesize(1, 1, 3) hand.speed(0) # 建立输出文字Turtle printer = turtle.Turtle() # 隐藏画笔的turtle形状 printer.hideturtle() printer.penup() def SetupClock(radius): # 建立表的外框 turtle.reset() turtle.pensize(7) turtle.pencolor(\"black\") turtle.fillcolor(\"green\") for i in range(60): Skip(radius) if i % 5 == 0: turtle.forward(20) Skip(-radius - 20) Skip(radius + 20) if i == 0: turtle.write(int(12), align=\"center\", font=(\"Courier\", 14, \"bold\")) elif i == 30: Skip(25) turtle.write(int(i / 5), align=\"center\", font=(\"Courier\", 14, \"bold\")) Skip(-25) elif (i == 25 or i == 35): Skip(20) turtle.write(int(i / 5), align=\"center\", font=(\"Courier\", 14, \"bold\")) Skip(-20) else: turtle.write(int(i / 5), align=\"center\", font=(\"Courier\", 14, \"bold\")) Skip(-radius - 20) else: turtle.dot(5) Skip(-radius) turtle.right(6) def Week(t): week = [\"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\", \"星期日\"] return week[t.weekday()] def Date(t): y = t.year m = t.month d = t.day return \"%s-%d-%d\" % (y, m, d) def Tick(): # 绘制表针的动态显示 t = datetime.today() second = t.second + t.microsecond * 0.000001 minute = t.minute + second / 60.0 hour = t.hour + minute / 60.0 secHand.setheading(6 * second) minHand.setheading(6 * minute) hurHand.setheading(30 * hour) turtle.tracer(False) printer.forward(65) printer.write(Week(t), align=\"center\", font=(\"Courier\", 14, \"bold\")) printer.back(130) printer.write(Date(t), align=\"center\", font=(\"Courier\", 14, \"bold\")) printer.home() turtle.tracer(True) # 100ms后继续调用tick turtle.ontimer(Tick, 100) def main(): # 打开/关闭龟动画，并为更新图纸设置延迟。 turtle.tracer(False) Init() SetupClock(160) turtle.tracer(True) Tick() turtle.mainloop() if __name__ == \"__main__\": main() 效果如图 再后来我我看见了git优秀的项目。。。 # coding:utf-8 from turtle import* def nose(x,y):#鼻子 pu() goto(x,y) pd() seth(-30) begin_fill() a=0.4 for i in range(120): if 0\u003c=i\u003c30 or 60\u003c=i\u003c90: a=a+0.08 lt(","date":"2020-04-20","objectID":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/:0:3","tags":["Python语言程序设计","Turtle库","绘图"],"title":"用Python绘图之Turtle(海龟)库详解","uri":"/py4_%E7%94%A8python%E7%BB%98%E5%9B%BE%E4%B9%8Bturtle%E6%B5%B7%E9%BE%9F%E5%BA%93%E8%AF%A6%E8%A7%A3/"},{"categories":["Python语言程序设计"],"content":"关键字也称为保留字，可以看作是构成python的最小单位语言。 # 获取Python的所有关键字 import keyword for i in keyword.kwlist: print(i) # 输出结果： False None True and as assert async await break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield 2020/04/16 现在我还不太明确每一个关键字代表的含义和它的用法，等我学习后再回头补充总结吧。 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 ","date":"2020-04-19","objectID":"/py3_python%E7%9A%8435%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E7%94%A8%E6%B3%95/:0:0","tags":["Python语言程序设计","false","None","true","and","as","assert","async","await","break","class","continue","def","del","elif","else","except","finally","for","from","global","if","import","in","is","lambda","nonlocal","not","or","pass","raise","return","try","while","with","yield","Python关键字"],"title":"Python的35个关键字的含义及用法","uri":"/py3_python%E7%9A%8435%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E7%94%A8%E6%B3%95/"},{"categories":["Python语言程序设计"],"content":"之前学习C语言的时候，是先学习C的各种概念后才去动手的，这次我希望先动手操作，再去慢慢理解它的原理。学习一门新语言时，当然少不了”Hello Word“ #传统操作 \"\"\"多行 注释\"\"\" print(\"Hello Word!\") 先对与C来说，输出hello word简直是太简单了。有了C的基础，学习Python也容易很多。不难发现，在 Python 程序中使用 # 可以对代码进行单行注释，用三个单引号或三个双引号将注释的内容括起来，则是多行注释。print()函数也与C中的printf()有区别,在函数后不用加分号（；）了。 #温度转换.py TempStr = input(\"请输入带有符号的温度值：\") if TempStr[-1] in ['F','f']: C = (eval(TempStr[0:-1]) - 32)/1.8 print(\"转换后的温度是{:.2f}C\".format(C)) elif TempStr[-1] in ['C', 'c']: F = 1.8*eval(TempStr[0:-1]) + 32 print(\"转换后的温度是{:.2f}F\".format(F)) else: print(\"输入格式错误\") 在python中，与C不同的时不需要在每一条语句后面加上分号，而Python中是通过缩进来判断语句是否执行完毕，一般的是四个空格，在同一个文本中缩进格式必须是一致的，尽量少使用tab键缩进。 短短的十行代码，它包括了四种数据类型，整数、浮点数、字符串和列表。 TempStr是字符串类型，字符串顾名思义就是一对单引号或双引号表示，由0个或多个字符组成的有序字符序列。索引的下标是从0开始，字符串有正向递增和反向递减的序号，比如TempStr[-1]，就是索引TempStr这个字符串中，倒数第一个字符串。 列表刚开始我以为列表很难理解，当我深入了解发现，其实列表相当于C语言中的数组，与C语言数组不同的是：列表可以存储任意数据类型的数据。列表中的每一个元素分配一个索引号，且索引的下标是从0开始。与C语言的数组类似。 关键字 in可以判断字符串是否在列表中，比如TempStr[-1] in [‘F’,‘f’]判断，TempStr字符串的最后一个字符是否与列表的某一个元素相同，如果相同则返回True否则False。 分支语句 if else elif要注意格式和c不同，例如：if 条件 **：**如果中间的条件为True，它将执行冒号之后的带有缩进的语句。 函数函数能根据参数产生不同的输出功能的过程。 \u003c变量\u003e = input(“这里是提示作用的字符串”) print（”\u003c字符串\u003e“） eval()作用就是去掉参数最外侧的引号（单引号和双引号）然后执行里面余下语句的函数，假如 TempStr[0:-1] = “123”，eval(TempStr[0:-1])就是把字符串”123“转换为数字123。 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 ","date":"2020-04-18","objectID":"/py2_python%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/:0:0","tags":["Python语言程序设计","温度转换程序","Hello World","in","列表","eval()"],"title":"Python第一个程序——温度转换","uri":"/py2_python%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2/"},{"categories":["Python语言程序设计"],"content":"我为什么选择Python作为第二门系统学习的计算机编程语言？ 我听说过很多编程语言，比如Basic, C,C++, C#, CSS, Fortran, Go, HTML, Java, JavaScript, Lisp, Lua, Matlab, Object C, Pascal, Perl, PHP, PostScript, Python, Ruby, Scala, SQL, Swift, VBA, VB.NET, Verilog, VHDL, Visual Basic等等。各编程语言所处历史时期和使命不同，但是作为我都第二门系统学习的计算机编程语言来说，通过比较他们的各方面，以及仔细想想未来所从事的工作来说，Python刚好是我需要的。 2018年以后的计算环境…计算机性能不再是解决一般问题的瓶颈移动互联网广泛普及大数据、云计算、物联网、信息安全、人工智能等需求爆发，如果不为以后做准备，那将会在这个社会上难以生存。 人生苦短，我学Python 经常有人开玩笑说，如果执行一个项目，C需要1000行代码，Java需要100行代码，而Python只需要10行代码，虽然这有夸张的成分在，但不可否认的是，python相对于其它计算机编程语言的代码量确实要少一些。Python 是最接近 AI 的语言，Python 被称为是机器学习最优秀的语言，没有之一。这也是我为什么想要学习Python最重要的原因。 ","date":"2020-04-17","objectID":"/py1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0python/:0:0","tags":["Python语言程序设计","Python优点","Python缺点"],"title":"为什么要学习Python？","uri":"/py1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0python/"},{"categories":["Python语言程序设计"],"content":"优点 1.Python是一种脚本语言，写好了就可以直接运行，省去了编译链接的麻烦，对于需要多动手实践的初学者而言，也就是少了出错的机会。 2.Python还有一种交互的方式，如果是一段简单的小程序，连编辑器都可以省了，直接敲进去就能运行。 3.Python提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（Batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 4.使用Python写程序很容易懂，这是很多人的共识。Python是一种面向对象的语言，但它的面向对象却不象C++那样强调概念，而是更注重实用。而是用最简单的方法让编程者能够感受到面向对象带来的好处，这正是Python能像Java、C#那样吸引众多支持者的原因之一。 ","date":"2020-04-17","objectID":"/py1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0python/:0:1","tags":["Python语言程序设计","Python优点","Python缺点"],"title":"为什么要学习Python？","uri":"/py1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0python/"},{"categories":["Python语言程序设计"],"content":"缺点 1.运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 2.代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 参考资料:Python语言程序设计基础(第2版)》嵩天、礼欣、黄天羽著，高等教育出版社，2017.2（讲授Python 3版本） 视频课程 ","date":"2020-04-17","objectID":"/py1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0python/:0:2","tags":["Python语言程序设计","Python优点","Python缺点"],"title":"为什么要学习Python？","uri":"/py1_%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0python/"},{"categories":["其它"],"content":"Hello World 中文意思是『你好,世界』。因为《The C Programming Language》中使用它做为第一个演示程序，非常著名，所以后来的程序员在学习编程或进行设备调试时延续了这一习惯。","date":"2020-03-26","objectID":"/hellomyblog/","tags":["其它"],"title":"Hello Myblog","uri":"/hellomyblog/"},{"categories":["其它"],"content":"我为什么写博客？ 几乎每一个程序员都听说过写博客有很多好处，但真的动手去写的却很少。其中有一个很重要的原因就是，有些人心里会认为：我不是大牛，写出来的博客没意义。其实我没创建博客之前也是这么想的，我身边没有一个人是写博客的。难道是我身处二本学校的缘故吗？我思考了好几天，好几天失眠，最终无果。 我是一个不会轻易的向困难低头，更不会轻易认输的人。虽然我来自一个普通的二本学校，但我相信习大大说的话，幸福都是奋斗出来的。努力不一定成功，但不努力是真的好爽。都说万事开头难，我们不管做什么事，最难的就是从零到一的过程。只要你跨过了，什么都是那么的自然。不管写的多差，只要我坚持，总能找到感觉的 我总是说我的表达能力还不行。从另一方面也说明，我对这个问题或是知识点了解得还不够透彻。如果我知道了来龙去脉、前因后果不会说得不清除的。 人都有一个遗忘规律。现在我认为已经烂记于心的东西，几个月后说不定就模糊了。其实，很多时候我们都是在反复的记忆遗忘做斗争。当然，这也是为以后工作做准备，如果遗忘了某些知识，至少还能回头看看，不至于重新学。 通过博客轨迹，我以后也可以看到自己的成长轨迹。我都做过些什么，以后应该怎么做，以至于不忘初心，不迷失自己。 Hello World 中文意思是『你好,世界』。因为《The C Programming Language》中使用它做为第一个演示程序，后来成为了的大多数程序员在学习编程时的第一课内容。现在我就用Hello myblog来开始我的博客生涯吧！ 1 #include \u003cstdio.h\u003e 2 3 int main() 4 { 5 printf(\"Hello World！\\n\"); printf(\"Hello myblog！\\n\"); 6 return 0; 7 } 本博客网站建成于2020年3月26日，在建成之前，我其实也有断断续续的写过博文。 ","date":"2020-03-26","objectID":"/hellomyblog/:0:0","tags":["其它"],"title":"Hello Myblog","uri":"/hellomyblog/"},{"categories":["其它"],"content":"为什么要写博客？ 几乎每一个程序员都听说过写博客有很多好处，但真的动手去写的却很少。其中有一个很重要的原因就是，有些人心里会认为：我不是大牛，写出来的博客没意义。其实我没创建博客之前也是这么想的，我身边没有一个人是写博客的。难道是我身处二本学校的缘故吗？我思考了好几天，好几天失眠，最终无果。 我是一个不会轻易的向困难低头，更不会轻易认输的人。虽然我来自一个普通的二本学校，但我相信习大大说的话，幸福都是奋斗出来的。努力不一定成功，但不努力是真的好爽。都说万事开头难，我们不管做什么事，最难的就是从零到一的过程。只要你跨过了，什么都是那么的自然。不管写的多差，只要我坚持，总能找到感觉的 我总是说我的表达能力还不行。从另一方面也说明，我对这个问题或是知识点了解得还不够透彻。如果我知道了来龙去脉、前因后果不会说得不清除的。 人都有一个遗忘规律。现在我认为已经烂记于心的东西，几个月后说不定就模糊了。其实，很多时候我们都是在反复的记忆遗忘做斗争。当然，这也是为以后工作做准备，如果遗忘了某些知识，至少还能回头看看，不至于重新学。 通过博客轨迹，我以后也可以看到自己的成长轨迹。我都做过些什么，以后应该怎么做，以至于不忘初心，不迷失自己。 Hello World 中文意思是『你好,世界』。因为《The C Programming Language》中使用它做为第一个演示程序，后来成为了的大多数程序员在学习编程时的第一课内容。现在我就用Hello myblog来开始我的博客生涯吧！ 1 #include \u003cstdio.h\u003e 2 3 int main() 4 { 5 printf(\"Hello World！\\n\"); printf(\"Hello myblog！\\n\"); 6 return 0; 7 } 本博客网站建成于2020年3月26日，在建成之前，我其实也有断断续续的写过博文。 ","date":"2020-03-26","objectID":"/hellomyblog/:0:0","tags":["其它"],"title":"Hello Myblog","uri":"/hellomyblog/"},{"categories":["计算机组成原理"],"content":"基于上一篇文章3.1定点数运算及溢出检测的学习，这次需要完成的定点数补码加、减运算器的设计。 ","date":"2020-03-13","objectID":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/:0:0","tags":["计算机组成原理","定点数运算","全加器","溢出检测","加减法运算器","补码"],"title":"3.2 定点数补码加、减运算器设计","uri":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机组成原理"],"content":"什么是全加器？ 在开始之前，需要复习一下数字电路中学到的全加器。全加器英语名称为full-adder，是用门电路实现两个二进制数相加并求出和的组合线路，称为一位全加器。一位全加器可以处理低位进位，并输出本位加法进位。多个一位全加器进行级联可以得到多位全加器。常用二进制四位全加器74LS283。 一位全加器的真值表如下图，其中Ai为被加数，Bi为加数，相邻低位来的进位数为Ci-1，输出本位和为Si。向相邻高位进位数为Ci 输入 输入 输入 输出 输出 Ci-1 Ai Bi Si Ci 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 一位全加器的表达式如下： Si=Ai⊕Bi⊕Ci-1 ","date":"2020-03-13","objectID":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/:0:1","tags":["计算机组成原理","定点数运算","全加器","溢出检测","加减法运算器","补码"],"title":"3.2 定点数补码加、减运算器设计","uri":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机组成原理"],"content":"加法运算器设计 四位串行加法器的设计（基于一位全加器FA） 根据 [X]补 + [Y]补 = [X + Y]补。利用一位全加器（FA )作为基本的加法单元，低位FA的进位输出直接送入相邻高位FA的进位输人，构成一个串行进位链。 四位串行加/减法器设计 利用一位全加器（FA )作为基本的加法单元，低位FA的进位输出直接送入相邻高位FA的进位输人，构成一个串行进位链。 当P等于1时，是减法运算器。减法运算器根据 [X + Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补。如何实现【Y】补转换为【-Y】补？只需要在B输入端连接异或门，与1异或。就可以得到Bi的反码，再从C0端＋1，就可以将【Y】补转换为【-Y】补。 三种带溢出检测功能的加/减运算器 第一种 tip 1、X0 和Y0为参与运算的原始符号位。S0为结果的符号位。 第二种 tip 运算时最高有效数据位产生的进位信号为C1，符号位产生的进位信号为C0。如下图 第三种 带无符号数溢出检测功能的加/减运算器 ","date":"2020-03-13","objectID":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/:0:2","tags":["计算机组成原理","定点数运算","全加器","溢出检测","加减法运算器","补码"],"title":"3.2 定点数补码加、减运算器设计","uri":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机组成原理"],"content":"改进 对于上面的串行加减法器，如果数据不是很大时，时延就不会明显感觉到，如果是进行大数据运算，那么串行进位的时延就很大，串行进位的运算速度慢。因此我们需要将串行改为并行，以满足大数据运算的需求。由一位全加器的表达式可知 Cin都是上一位全加器的Cout，因此它需要等待上一位的Cout计算出来才能执行下一步。但如果把Cin替换为上一位Cout的表达式，则不需要等待上一步运算。大大降低了时延。 从C4中又可以得到进位产生函数G和进位传输函数P，P相当于把C0传输到C4的输出，如果P等于1时，C0就为了C4做了贡献。因此得到了四位并行ALU，那如何进行由四位并行ALU去构造位数更多的ALU呢？答案很简单，只要把他们像四位FA串行连接的方法即可。那就分成了四段，每段又变成了串行运算。我们需要把这16位段间串行的ALU改造成完全并行的ALU。对每一段的进位输出和进位输入得到表达式进行分析得到，C4C8C12C16也是像刚开始的串行进位一样，因此利用代入的方法，消除串行进位和相互依存的关系，构成一个16位完成并行的ALU。注意：16位完全并行ALU也有进位产生函数G和进位传输函数P 参考资料 ","date":"2020-03-13","objectID":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/:0:3","tags":["计算机组成原理","定点数运算","全加器","溢出检测","加减法运算器","补码"],"title":"3.2 定点数补码加、减运算器设计","uri":"/3.2-%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机组成原理"],"content":"数据在计算机中是以一定的编码方式表示的，常用的编码有原码、反码、补码和移码。同一种算术运算，使用不同的编码，有不同的运算法则。由第2章对不同机器数特点的分析可知，采用补码数据表示，不仅符号位同数值位一起参加运算，而且还可以把减法变成加法实现。因此基于补码数据表示的定点补码加减法运算具有运算规则简单，易于实现等优点。 ","date":"2020-03-12","objectID":"/3.1%E5%AE%9A%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B/:0:0","tags":["计算机组成原理","定点数运算","溢出","溢出检测","加法","减法","原码， 补码"],"title":"3.1定点数运算及溢出检测","uri":"/3.1%E5%AE%9A%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B/"},{"categories":["计算机组成原理"],"content":"定点数的运算 定点数的运算是基于定点补码来进行运算的！ 定点数的加法 定点数加法的运算满足这个公式： [X]补 + [Y]补 = [X + Y]补 例： 理解：要求X+Y，首先将X转化为补码的形式（正数：0+原数，负数：1+余各项取反，最后在末尾+1），利用公式X[补] + Y[补] = [X + Y]补 求得[X + Y]补 ，然后再转换为原码。 再举个例子： 设 x =0 .1010，y = - 0.0100，求x + y =？ [Y]补和[-Y]补的规律 通过推到我们得出一个很重要的规律： （1）已知[Y]补快速求出[ - Y]补 从右向左扫描[Y]补，在遇到数字1及之前，直接输出遇到的数字，遇到第一个1之后，取反输出，即可得到[-Y]补。 （2）已知[Y]补快速求出[ - Y]补 从右向左扫描[ - Y]补，在遇到数字0及之前，直接输出遇到的数字，遇到第一个0之后，取反输出，即可得到[Y]补。 定点数的减法 定点数减法的运算满足这个公式： [X + Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补 例：再举两个个例子：设X=-0.1001，y=-0.0110 ,求 x - y 设X= 0.1001，y = 0. 0110,求[x]补一[y]补 ","date":"2020-03-12","objectID":"/3.1%E5%AE%9A%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B/:0:1","tags":["计算机组成原理","定点数运算","溢出","溢出检测","加法","减法","原码， 补码"],"title":"3.1定点数运算及溢出检测","uri":"/3.1%E5%AE%9A%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B/"},{"categories":["计算机组成原理"],"content":"溢出 溢出的概念及其判断方法 1、运算结果超出数据类型所能表示数据范围的现象称为溢出。上面两个例子的运算结果都是错误的，其原因就是因为运算的结果超过了定点小数所能表示的数据范围，两个正数之和应该等于一个正数，两个负数之和应该等于一个负数，但上面的例子中却并非如此。 2、由于机器字长是确定的，所以能表示的数据范围也是有限的，溢出现象不可避免。而溢出往往可能导致有效数字丢失或直接导致错误的运算结果，因此，对于计算机系统设计者而言，必须解决溢出的判断问题，以便溢出发生时计算机应能做出相应的处理。 有多种方法可以检测出溢出，下面将主要介绍常见的3种方法。 1）溢出检测第一种方法 1)根据操作数和运算结果的符号位是否一致进行检测显然，只有两个符号相同的数相加时才有可能产生溢出，因此，可根据操作数和运算结果的符号位是否一致进行检测。 基于该方法实现溢出检测的逻辑表达式如公式所示： 2）溢出检测第二种方法 2)根据运算过程中最高数据位的进位与符号位的进位位是否一致进行检测设运算时最高有效数据位产生的进位信号为C1，符号位产生的进位信号为C0 当两个正数相加时，C0必然等于0，此时判断最高数据位相加产生的进位是1还是0，如果没有产生进位（也就是0），则无溢出。若进位为1，则改变了结果的符号位，发生溢出。负数相加时同理。 3）溢出检测第三种方法 利用变形补码进行检测变形补码，即用两个二进制符号位来表示数据的符号位（例如：Xf1，Xf2，X0,X1,X2…….Xn Xf1、Xf2分别称为第一符号位和第二符号位），其余与补码相同。对定点小数而言，采用变形补码后，其模为4,因此，也称为“模4补码”；对整数而言，采用变形补码后，其模为2\"+2 ( n为数值位的位数）。 参考资料 ","date":"2020-03-12","objectID":"/3.1%E5%AE%9A%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B/:0:2","tags":["计算机组成原理","定点数运算","溢出","溢出检测","加法","减法","原码， 补码"],"title":"3.1定点数运算及溢出检测","uri":"/3.1%E5%AE%9A%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E5%8F%8A%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B/"},{"categories":["计算机组成原理"],"content":"一、总结 真值： 正号和负号分别用“ + ”和“ - ”表示，数据位保持二进制值不变的数据表示方法。 数值数据：计算机所支持的一种数据类型，用于科学计算，常见的数值数据类型包括小数、整数、浮点数数等。 非数值数据：计算机所支持的一种数据类型，一般用来表示符号或文字等没有数值值的数据。 机器数：数据在机器中的表示形式，是正负符号数码化后的二进制数据。 变形补码：用两个二进制位来表示数字的符号位，其余与补码相同。即“ 00 ”表示正，“ 11 ”表示负。 规格化：将非规格化的数处理成规格化数的过程。规格化数规定尾数用纯小数表示，且真值表示时小数点后第一位不为 0 （以机器数表示时对小数点后第一位的规定与具体的机器数的形式有关）。 机器零： 计算机保存数字的位有限，所能表示最小的数也有范围， 其中有一个范围之中的数据无法精确表示，当实际的数据处在这个无法精确表示的数据范围时计算机就将该数作为机器零来处理，因此，计算机中的机器零其实对应的不是一个固定的数，而是一个数据表示范围。 BCD 码： 用 4 位二进制数来表示 1 位十进制数中的 0~9 这 10 个数码，即二进制表示的十进制数。 汉字内码： 计算机内部存储、处理加工和传输汉字时所用的由 0 和 1 符号组成的代码。 码距： 一组编码中对应位上数字位不同的最小个数。 奇偶校验：通过检测校验码中 1 的个数的奇 / 偶性是否改变来判断数据是否出错的一种数据校验方法。 海明校验：是一种基于多重奇校验且具有检测与纠正错误的校验方法。其基本原理是 将有效信息按某种规律分成若干组，每组安排一个校验位进行奇偶测试，就能提供多位检错信息，以指出最大可能是哪位出错，从而将其纠正。 循环冗余校验： 是数据通信领域中最常用的一种 具有检测与纠正错误能力 差错校验码， 基利用生成多项式并基于模 2 运算建立编码规则。 检错：检测被传送的信息中是否发生差错。 纠错： 纠正信息在传送或存储过程中所发生的错误。 二、练习 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:0","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"1) 为什么计算机中采用二进制 ? 答： 因为二进制具有运算简单和表示简单的优点，除此之外还有可靠和容易实现等特点。 具体来说，是因为： （ 1 ）技术实现简单，计算机是由逻辑电路组成，逻辑电话通常只有两个状态，开关 的接通与断开，这两种状态正好可以用“ 1 ”和“ 0 ”表示。 （ 2 ）简化运算规则：两个二进制数和、积运算组合各有三种，运算规则简单，有利 于简化计算机内部结构，提高运算速度。 （ 3 ）适合逻辑运算：逻辑代数是逻辑运算的理论依据，二进制只有两个数码，正好 与逻辑代数中的“真”和“假”相吻合。 （ 4 ）易于进行转换，二进制与十进制数易于互相转换。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:1","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"2) 为什么计算机中采用补码表示带符号的整数 ? 答： 采用补码运算具有如下两个特征： （ 1 ） 因为使用补码可以将符号位和其他位统一处理，同时，减法也可以按加法来处理，即如果是补码表示的数，不管是加减法都直接用加法运算即可实现。 （ 2 ） 两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。 这样的运算有两个好处： （ a ） 使符号位能与有效值部分一起参加运算，从而简化运算规则。从而可以简化运算器的结构，提高运算速度；（减法运算可以用加法运算表示出来。） （ b ） 加法运算比减法运算更易于实现。使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:2","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"3) 浮点数的表示范围和精确度分别由什么决定 ? 字长一定时浮点数的表示范围与精确度之间有和关系 ? 答：浮点数的表示范围由阶码的位数决定，精确度由尾数的位数决定。 当机器字长一定时，分给阶码的位数越多，尾数占用的位数就越少，则数的表示范围越大。而尾数占用的位数减少，必然会减少数的有效数位，即影响数的精度。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:3","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"4) 汉字输入码、机内码和字型码在汉字处理过程中各有何作用？ 答：汉字输入码、机内码和字型码，分别用于汉字的输入、汉字在计算机内的处理以及汉字的显示和打印。 具体来说，计算机要对汉字信息进行处理，首先要将汉字转换成计算机可以识别的二进制形式并输入到计算机，这是由汉字输入码完成的；汉字输入到计算机后，还需要转换成内码才能被计算机处理，显然，汉字内码也应该是二进制形式。如果需要显示和打印汉字，还要将汉字的内码转换成字形码。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:4","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"5) 在机内码中如何区分两个 ASCII 码字符和一个汉字 ? 答：将一个汉字看成是两个扩展 ASCII 码，使表示 GB2312 汉字的两个字节的最高位都为 1 ，而每个 ASCII 码字符中每个字节的最高位为 0 。这样就能区别一个机内码到底对应一个汉字还是两个西文字符。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:5","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"6) “ 8421 码 就是二进制数”。这种说法对吗？为什么？ 答：这种说法是不对的。 8421 码 是一种最简单的有权码， 它选取 4 位二进制数的前 10 个代码 0000 ～ 1001 分别对应表示十进制数的 10 个数码。若按权求和，和数就等于该代码所对应的十进制数。 8421 码 是一种编码方式，用于十进位制与二进制数之间的转换。 而 二进制数是用 0 和 1 两个数码来表示的数。二者是不同的概念，不能等同。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:6","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"7) 如何识别浮点数的正负？浮点数能表示的数值范围和数值的精确度取决于什么？ 答：当采用一般浮点数格式表示浮点数时 , 阶码和尾数都各包含一位符号位。浮点数的正负由尾数的的符号位决定。当采用 IEEE754 格式时，通过数符就能判断出浮点数的正负。 浮点数能表示的数值范围和数值的精确度，分别取决于阶码的位数和尾数的位数。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:7","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"8) 简述 CRC 的纠错原理。 答：发送部件将某信息的 CRC 码传送至接收部件，接收部件收到 CRC 码后，仍用约定的生成多项式 G(x) 去除，若余数为 0 ，表示传送正确；若余数不为 0 ，表示出错，再由余数的值来确定哪一位出错，从而加以纠正。具体的纠错原理如下： （ 1 ） 不论错误出现在哪一位 , 均要通过将出错位循环左移到最左边的一位上时被纠正； （ 2 ） 不为零余数的具有循环特性。即在余数后面补一个零除以生成多项目式 , 将得到下一个余数 , 继续在新余数基础上补零除以生成多项式 , 继续该操作，余数最后能循环到最开始的余数。 （ 3 ） CRC 就是利用不为零余数的循环特性 , 在循环计算余数的同时，将收到的 CRC 编码同步移动，当余数循环到等于最左边位出错对应的余数时，表明已将出错的位移到 CRC 码的最左边 , 对出错位进行纠错。 （ 4 ） 继续进行余数的循环计算 , 并同步移动 CRC 编码 , 当余数又回到最开始的值时 , 纠错后的 CRC 码又回到了最开始的位置。至此，完成 CRC 的纠错任务。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:8","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"9)写出下列各数的原码、反码和补码。 0 ， 一 0 ， 0.10101 ， 一 0.10101 ， 0.11111 ， 一 0.11111 ， － 0.10000 ， 0.10000 解： x=0 ，则［＋ 0 ］ 原 ＝ 0.00 … 0 ， [ ＋ 0 ] 反 ＝ 0.00 … 0 ，［＋ 0 ］ 补 ＝ 0.00 … 0 ； x=-0 ，则［－ 0 ］ 原 ＝ 1.00 … 0 ， [ － 0] 反 ＝ 1.11 … l ， [ － 0] 补 ＝ 0.00 … 0 ； x= 0.10101 ，则［ x ］ 原 ＝ 0.10101 ， [x] 反 ＝ 0.10101 ， [x] 补 ＝ 0.10101 ； x= 一 0.10101 ，则［ x ］ 原 ＝ 1.10101 ， [x] 反 ＝ 1.01010 ， [x] 补 ＝ 1.01011 ； x= 0.11111 ，则［ x ］ 原 ＝ 0.11111 ， [x] 反 ＝ 0.00000 ， [x] 补 ＝ 0.00001 ； x= 一 0.11111 ，则［ x ］ 原 ＝ 1.11111 ， [x] 反 ＝ 1.00000 ， [x] 补 ＝ 1.00001 ； x= － 0.10000 ，则［ x ］ 原 ＝ 1.10000 ， [x] 反 ＝ 1.01111 ， [x] 补 ＝ 1.10000 ； x= 0.10000 ，则［ x ］ 原 ＝ 0.10000 ， [x] 反 ＝ 0.10000 ， [x] 补 ＝ 0.10000 。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:9","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"10)已知 x ＝ 0.10110,y ＝ —0.01010, 求： [x/2] 补 , [x/4] 补 , [y/2] 补 , [2y] 补 解： [x] 原 =0.10110=[x] 反 =[x] 补 ， 所以 [x/2] 补 =0.010110 ， [x/4] 补 =0.0010110 ； [y] 原 =1.01010 ， [y] 反 =1.10101 ， [y] 补 =1.10110 ， 所以 [y/2] 补 =1.110110 ， [2y] 补 =1.0110 。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:10","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"11)C 语言中允许无符号数和有符号整数之间的转换 , 下面是一段 C 语言代码 , 给出在 32 位计算机中上述程序段的输出结果并分析原因 。 int x =-1; Unsigned u=2147483648; Printf (“x=%u=%d\\n”,x,x); Printf (“u=%u=%d\\n”,u,u); 原因： x 是 int 型，在计算机中以补码形式存在。 %u 以无符号输出， %d 输出真值 , 所以 x=4294967295=-1 。 u=2 31 是一个无符号数，无溢出，由于首位为 1 %u 符号输出第一位为非符号位，所以是 2147483648 %d 第一位为符号位，所以是负数，取反加 1 还是 2 31 所以是 -2147483648 。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:11","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"12)用 IEEE754 32位浮点数标准表示十进制数 a) b) 3.1415927 c )64000 解： a) 首先分别将整数和分数部分转换成二进制数 ： =-110.101 移动小数点，使其 变成 1.M 的形式： -110.101=-1.10101*2 2 于是得到： S=0, e = 2 ， E= 10 + 01111111 = 10000001 ， M = 10101 最后得到 32 位浮点数的二进制存储格式为： 1 100 0000 1 101 0100 0000 0000 0000 0000= （ C0D40000 ） 16 b) 首先分别将整数和分数部分转换成二进制数： 3.1415927 = 11.00100100001111110110101 移动小数点，使其 变成 1.M 的形式 11.00100100001111110110101 = 1.100100100001111110110101 × 2 于是得到： S=0, e = 1 ， E= 1 + 01111111 = 10000000 ， M = 10010010000111111011010 最后得到 32 位浮点数的二进制存储格式为： 0 100 0000 0 100 1001 0000 1111 1101 1010= （ 40490FDA ） 16 c) 首先将 6400 转换成二进制数： 64000 =1100100000000 移动小数点，使其 变成 1.M 的形式 1100100000000=1.100100000000 × 2 12 于是得到： S=0, e = 12 ， E= 1100 + 01111111 = 10001011 ， M = 1001 最后得到 32 位浮点数的二进制存储格式为： 0 100 0101 1 100 1000 0000 0000 0000 0000=( 45C 80000) 16 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:12","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"13)求与 IEEE754 32 位浮点数 43940000H 对应的十进制数。 解： 43940000H= （ 0 100 0011 1 001 0100 0000 0000 0000 0000 ） 2 S=0 ， E= （ 10000111 ） 2 -127=8 ， M=1.00101 所以表示数为 100101000 ，对应的十进制数为 296 。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:13","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"14)设有效信息为 01011011，分别写出奇校验码和偶校验码。如果接收方收到的有效信息为 01011010，说明如何发现错误。 解：奇偶校验位分别为： 0 和 1 ， 奇校验码： 01011011 0 偶校验码： 01011011 1 如果采用奇校验，则发送方发出的奇校验码 x= 01011011 0 （前 8 位 是 有效信息位，最后一位 是 校验位）， 如果接收方收到的 x=01011010 0 ( 只有 1 位出错，最后一个 0 是校验位 ), 接收方按奇校验方式根据 01011010 计算得到的验位 C ’ ＝ 1 ，与从信息中读到得校验码的取值不同，表明传送的信息发生了错误。 如果采用偶校验，利用相似的方法可以发现错误。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:14","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"15)由6个字符的7位ASCII编码排列，再加上水平和垂直偶校验位构成如表2.23的行列结构（最后一列为水平奇偶校验位，最后一行为垂直奇偶校验位） 则 X 1 X 2 X 3 X 4 处的比特分别为 _1110 _ ； X 5 X 6 X 7 X 8 处的比特分别为 1000 ； X 9 X 10 X 11 X 12 处的比特分别为 _1011 _ ； Y 1 和 Y 2 处的字符分别为 I _ 和 __ 7 _ 。 解答思路：利用 交叉奇 / 偶校验 原理来确定各个 X 值，再查询 ASCII 码表获知 Y 1 和 Y 2 是什么字符。 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:15","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"16)设8位有效信息为01101ll0，试写出它的海明校验码。给出过程，说明分组检测方式，并给出指误字及其逻辑表达式。如果接收方收到的有效信息变成01101111，说明如何定位错误并纠正错误。 解：被检验位有 8 位，设检验位有 r 位 因为： 8+r\u003c=2 r -1 r=4; 设四位分别为 P1，P2，P3，P4 海明码为： P1 P2 0 P3 1 1 0 P4 1110 P1 ： 3 ， 5 ， 7 ， 9 ， 11 P2 ： 3 ， 6 ， 7 ， 10 ， 11 P3 ： 5 ， 6 ， 7 ， 12 P4 ： 9 ， 10 ， 11 ， 12 所以 P1=1 ， P2=1 P3=0 P4=1 海明码为： 110011011110 指错位 G1 ： 1 ， 3 ， 5 ， 7 ， 9 ， 11 G2 ： 2 ， 3 ， 6 ， 7 ， 10 ， 11 G3 ： 4 ， 5 ， 6 ， 7 ， 12 G4 ： 8 ， 9 ， 10 ， 11 ， 12 G1=0 ， G2=0 ， G3=0 ， G4=0 参考资料 ","date":"2020-03-11","objectID":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:16","tags":["计算机组成原理","总结","练习","奇偶校验","海明校验"],"title":"第二章数据表示总结与练习","uri":"/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"海明校验码是由理查德.海明（Richard H a m m i n g )于1950年提出的。它不仅具有检测错误的能力，同时还具有给出错误所在准确位置的能力。 ","date":"2020-03-10","objectID":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:0","tags":["计算机组成原理","冗余码","海明校验"],"title":"2.6海明校验及其实现","uri":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"1、增加冗余码（校验位） 海明校验不仅具有检测错误的能力，同时还具有给出错误所在准确位置的能力，但是因为这种海明校验的方法只能检测和纠正一位出错的情况。所以如果有多个错误，就不能查出了。 如要能检出与自动校正一位错，并能同时发现哪位错，此时校验位的位数r和数据位的位数k应满足下述关系: 2^r-1 ≥ k + r （有效信息(k位)校验信息(r位）） 设计海明码编码的关键技术，是合理地把每个数据位分配到r个校验组中，以确保能发现码字中任何一位出错；若要实现纠错，还要求能指出是哪一位出错，对出错位求反则得到该位的正确值。 ","date":"2020-03-10","objectID":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:1","tags":["计算机组成原理","冗余码","海明校验"],"title":"2.6海明校验及其实现","uri":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"举个例子 传送1011000 当传输无错时 当传输出错时 ","date":"2020-03-10","objectID":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:2","tags":["计算机组成原理","冗余码","海明校验"],"title":"2.6海明校验及其实现","uri":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"缺陷 指错字G4G3G2G1= 0000 不一定无错（利用偶校验的特点去判断） 指错字不一定能区别一位错与两位错 参考资料 ","date":"2020-03-10","objectID":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:3","tags":["计算机组成原理","冗余码","海明校验"],"title":"2.6海明校验及其实现","uri":"/2.6%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"循环冗余校验是一种基于模2运算建立编码规则的校验码。对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。CRC在磁存储器和计算机通信方面应用较多。 ","date":"2020-03-09","objectID":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:0","tags":["计算机组成原理","模2运算","CRC校验"],"title":"2.5CRC校验及其实现","uri":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"1.模2运算 1)模2加减运算 模2加减运算就是按位加减运算，即不带进位和借位的二进制加法和减法运算。模2加与模2减运算的结果相同。 运算规则如下：0±0 = 0，0±1 = 1，1±0 = 1，1士1 = 0 2)模2乘运算 模2乘运算即按模2加求部分积之和，无进位。例2. 2 1按模2乘法运算法则求1101与101之积。 3 )模2除运算 模2除运算即按模2减求部分余数，不借位。其上商原则是：(1)部分余数首位为1时，商为1，减除数。(2)部分余数首位为0时，商为0，减0。( 3 )当部分余数的位数小于除数的位数时，该余数为最后余数. ","date":"2020-03-09","objectID":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:1","tags":["计算机组成原理","模2运算","CRC校验"],"title":"2.5CRC校验及其实现","uri":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"CRC基本原理 （1）生成多项式G(x) 收发双方约定的一个(r + 1)位二进制数，发送方利用G(X)对信息多项式做模2除运算,生成校验码。接收方利用G(X)对收到的编码多项式做模2除运算检测差错及错误定位。 G(x)应满足的条件： A、最高位和最低位必须为1； B、当被传送信息（CRC码）任何一位发生错误时，被生成多项式做除后应该使余数不为0； C、不同位发生错误时，模2除运算后余数不同； D、对不为0余数继续进行模2除运算应使余数循环。 常见生成多项式G(x) （2）CRC 编码方法 （3）CRC的检错与纠错 假如无错则余数为0，假如出错则余数不为0，纠错需要查看表 ","date":"2020-03-09","objectID":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:2","tags":["计算机组成原理","模2运算","CRC校验"],"title":"2.5CRC校验及其实现","uri":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"CRC软件实现 ******该文件使用查表法计算CCITT 标准的CRC-16检验码，并附测试代码********/ #include #define CRC_INIT 0xffff//CCITT初始CRC为全1#define GOOD_CRC 0xf0b8//校验时计算出的固定结果值 /****下表是常用ccitt16,生成式1021反转成8408后的查询表格****/ unsigned short crc16_ccitt_table[256] = { 0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e,0xf8f7,0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,0x2102, 0x308b, 0x0210,0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5,0x453c,0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,0xce4c, 0xdfc5, 0xed5e,0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb,0xaa72,0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,0x7387, 0x620e, 0x5095,0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e,0xf0b7,0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,0x18c1, 0x0948, 0x3bd3,0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74,0x5dfd,0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,0xc60c, 0xd785, 0xe51e,0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb,0xa232,0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,0x6b46, 0x7acf, 0x4854,0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1,0x0f78 }; unsigned short do_crc(unsigned short reg_init, unsigned char *message, unsigned intlen) { unsigned short crc_reg= reg_init; while (len--) crc_reg= (crc_reg\u003e\u003e 8)^ crc16_ccitt_table[(crc_reg^*message++) \u0026 0xff]; return crc_reg; } ","date":"2020-03-09","objectID":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:3","tags":["计算机组成原理","模2运算","CRC校验"],"title":"2.5CRC校验及其实现","uri":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"CRC的应用 参考资料 ","date":"2020-03-09","objectID":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:4","tags":["计算机组成原理","模2运算","CRC校验"],"title":"2.5CRC校验及其实现","uri":"/2.5crc%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"什么是奇偶校验？ 奇偶校验是一种常见的简单校验。根据被传输的一组二进制代码的数位中“1”的个数是奇数或偶数来进行校验。采用奇数的称为奇校验，反之，称为偶校验。采用何种校验是事先规定好的。通常专门设置一个奇偶校验位，用它使这组代码中“1”的个数为奇数或偶数。若用奇校验，则当接收端收到这组代码时，校验“1”的个数是否为奇数，从而确定传输代码的正确性。 ","date":"2020-03-08","objectID":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:1","tags":["计算机组成原理","奇偶校验"],"title":"2.4奇偶校验及其实现","uri":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"奇偶校验的优缺点 1、编码与检错简单 2、编码效率高 3、不能检测偶数位错误, 无错结论不可靠，是一种错误检测码 4、不能定位错误，因此不具备纠错能力 ","date":"2020-03-08","objectID":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:2","tags":["计算机组成原理","奇偶校验"],"title":"2.4奇偶校验及其实现","uri":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"奇偶校验的码距 根据上一节我们得知，奇偶校验的码距为2，因为奇偶校验对于偶数位的错误是检测不出来的，所以他的最小码距是2，举例个例子说明11000011 和01000010。因此，奇偶校验可以检测出一位错误，无纠错能力。 ","date":"2020-03-08","objectID":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:3","tags":["计算机组成原理","奇偶校验"],"title":"2.4奇偶校验及其实现","uri":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"练习 1假设下列字符中有奇偶校验，但没有发生错误，其中采用的是奇校验的是 （ ）（单选） A.11011001 B.11010111 C.11010100 D.11110110 正确答案：A，因为字符码第一位是校验位，由于D的真值有四个1，所以校验位写成1凑成奇数，这也叫奇校验。 2下列关于奇偶校验的描述中，正确的是 （ ） （多选） A.奇校验和偶校验的码距都为1 B.编码时使用的校验位位数与被校验数据的长度无关 C.校验时得到的无错结论不可信 D.校验时得到的有错结论不可信 正确答案：B、C 3设奇偶校验编码总长度大于3位，下列关于基本奇偶校验检错与纠错能力的描述，正确的是 （ ） （多选） A.可以检测1位错误 B.可以检测2位错误 C.可以检测3位错误 D.不能纠正错误 正确答案：A、C、D，奇偶校验可检测奇数个错误，无纠错能力。 参考资料 ","date":"2020-03-08","objectID":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/:0:4","tags":["计算机组成原理","奇偶校验"],"title":"2.4奇偶校验及其实现","uri":"/2.4%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"},{"categories":["计算机组成原理"],"content":"受元器件的质量、电路故障或噪音干扰等因素的影响，计算机在对数据进行处理、传输及存储过程中，往往会出现错误。如何发现或纠正上述过程中的数据错误，是计算机系统设计者必须面临的问题。 ","date":"2020-03-07","objectID":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:0:0","tags":["计算机组成原理","码距","海明校验"],"title":"2.3数据校验基本原理","uri":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"码距 （1）什么是码距？ 在信息编码中，两个合法代码对应位上编码不同的位数称为码距，又称海明距离。 （2）举个栗子？ 比如说到码A和码B的码距，就是看从A到B有几个2进制位翻转… 1100和1101之间码距为1，因为只有最低位翻转了。 而1001和0010之间码距则为3，因为只有1位没有变化。 10101和00110从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。 简单来说，计算海明距离的一种方法，就是对两个位串进行异或（xor）运算，并计算出异或运算结果中1的个数。例如110和011这两个位串，对它们进行异或运算，其结果是： [2] 110⊕011=101 异或结果中含有两个1，因此110和011之间的海明距离就等于2。 有了码距的概念，就可以知道码距与检错或纠错能力的关系，如下图 ","date":"2020-03-07","objectID":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:0:1","tags":["计算机组成原理","码距","海明校验"],"title":"2.3数据校验基本原理","uri":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"如何选择码距 （1）在确定与使用数据校验码时，应该考虑在不过多增加硬件开销的情况下，尽可能发现或改正更多的错误。 （2）码距越大，抗干扰能力越强，纠错能力越强，数据冗余越大，编码效率低，编码电路也相对复杂； （3）选择码距必须考虑信息发生差错的概率和系统能容许的最小差错率。 ","date":"2020-03-07","objectID":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:0:2","tags":["计算机组成原理","码距","海明校验"],"title":"2.3数据校验基本原理","uri":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"练习 1、下列编码中码距为2的编码是( ) （多选） A.0011, 1100, 0000, 0101 B.00 , 11, 01, 10 C.000, 101, 110 D.00000， 11100， 00111， 10100 正确答案：A、C 2下列关于码距与检错与纠错能力的描述中正确的是 （ ） （多选） A.码距为1的编码不具备任何检错能力 B.码距为2的编码具有1位检错能力，但无纠错能力 C.码距为4的编码可检测出2位错误，并可纠正1位错误 D.码距为4的编码可检测出2位错误，并可纠正2位错误 正确答案：A、B、C 3下列关于校验的描述中，正确的是 （ ) （多选） A.校验码的基本原理就是通过增加校验位提高码距，从而使编码具有检错或纠错能力 B.码距越大，对应编码的检错与纠错能力就越强 C.码距越大，所需要的校验信息也就多，对应的编码效率就越低 D.校验既可采用硬件实现，也可采用软件实现 正确答案：A、B、C、D 参考资料 ","date":"2020-03-07","objectID":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/:0:3","tags":["计算机组成原理","码距","海明校验"],"title":"2.3数据校验基本原理","uri":"/2.3%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"一、定点数据表示 定点表示法约定机器中所有数据的小数点位置固定，其中，将小数点的位置固定在数据的最高数位之前(或符号位之后）的数据表示称为定点小数，而将小数点固定在最低数位之后的数据表示称为定点整数。另外，由于小数点位置固定，因而小数点可不必再用记号表示，也无需存储。 ","date":"2020-03-06","objectID":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:0","tags":["计算机组成原理","定点小数","定点整数","浮点数","IEEE浮点数"],"title":"2.2定点与浮点数据表示","uri":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"1.定点小数 设定点小数T的形式为X=X0. X1X2 …Xn，符号位X0用来表示数的正负，小数点的位置是约定的，机器中并不用器件去指示它。X1~Xn是数值的有效部分，也称为尾数，X1为最高有效位。 ","date":"2020-03-06","objectID":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:1","tags":["计算机组成原理","定点小数","定点整数","浮点数","IEEE浮点数"],"title":"2.2定点与浮点数据表示","uri":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"2 .定点整数 设定点整数X的形式为工X=X0X2X3X4~Xn. 定点数能表示的数据范围与下列因素有关。 1)字长。一般而言，字长越长，表示的数据范围就越大。 2)所采用的机器数表示方法。通过前面对几种不同机器数的分析可知，补码和移码数据表示所能表示的数据范围比原码和反码所能表示的数据范围要多一个数据单位。 ","date":"2020-03-06","objectID":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:2","tags":["计算机组成原理","定点小数","定点整数","浮点数","IEEE浮点数"],"title":"2.2定点与浮点数据表示","uri":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"3.定点数的数据表示范围 定点数的数据表示范受字长及采用的机器数形式等因素有关。 二、浮点数据表示 浮点表示法是小数位置点在数据中不固定，即小数点在数中可以浮动的一种数据表示方法，它由阶码和尾数两部分组成，其中阶码的位数决定数据的范围，尾数的位数决定数据的精确度。 ","date":"2020-03-06","objectID":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:3","tags":["计算机组成原理","定点小数","定点整数","浮点数","IEEE浮点数"],"title":"2.2定点与浮点数据表示","uri":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"1 .浮点数据表示的一般格式 EsE1E2E3E4E5E6…EnMsM1M2M3M4…Mk Es表示阶码的符号,E1~En为阶码的值。Ms表示尾数的符号（也决定整个数的正负）M1 ~Mk构成尾数，尾数是小于1的数。其中，阶码位数决定数的范围，尾数位数决定数的精确度。 分给阶码的位数越多，则留给尾数的位数就越少，所以说如果要表示更大的范围，就必须要牺牲精确度。反之亦然。 不足之处： 数据的移植性太差，不同思系统可能根据自己的浮点数格式从中提取不同位数的阶码。 ","date":"2020-03-06","objectID":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:4","tags":["计算机组成原理","定点小数","定点整数","浮点数","IEEE浮点数"],"title":"2.2定点与浮点数据表示","uri":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"2 .IEEE浮点数据表示 在浮点数据表示中，不同机器可能选用不同基、不同的阶码及尾数的位数，从而导致不同机器浮点数据表示的差异性较大，不利于软件的移植。为此，美国电气及电子工程师协会IEEE于1985年提出了浮点数标准IEEE 754，现在该浮点数标准已被主流计算机所采用。 单精度32位浮点数格式： 符号位S+8位偏指数E+23位有效尾数M 双精度64位浮点数格式： 符号位S+8位偏指数E+23位有效尾数M 指数采用偏移值，其中单精度偏移值为127，双精度为1023，将浮点 数的阶码值变成非负整数,便于浮点数的比较和排序。 IEEE754尾数形式为1.XXXXXX,其中M部分保存的是XXXXXX(1被隐 藏)，从而可保留更多的有效位，提高数据表示的精确度 以32位单精度为例，IEEE754格式相对应的32位浮点数的真值可表示为： 对于IEEE754的E和M取值的不同，其表示的意义也不同 IEEE75432位浮点数与对应真值之间的变换流程： 参考资料 ","date":"2020-03-06","objectID":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:5","tags":["计算机组成原理","定点小数","定点整数","浮点数","IEEE浮点数"],"title":"2.2定点与浮点数据表示","uri":"/2.2%E5%AE%9A%E7%82%B9%E4%B8%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"二进制具有运算简单、便于物理实现、节省设备等优点，所以被计算机采用。二进制数与十进制数一样有正负之分。 在计算机中，常采用数的符号和数值一起编码的方法来表示数据。常用的有原码、补码、反码和移码等几种表示方法，这几种表示法都将数据的符号数值化。对于原码、反码和补码而言，数据的最高位(最左位)为“0”时，表示该数为正数；数据的最高位（最左位）为“1”时，表示该数为负数。对于移码，则正好相反，数据的最高位为“0”时，表示该数为负数；数据的最高位为“1”时，表示该数为正数。为了区分一般书写时表示的数和机器中编码表示的数，我们称前者为真值，后者为机器数。 ","date":"2020-03-05","objectID":"/2.1%E6%9C%BA%E5%99%A8%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:0","tags":["计算机组成原理","原码","反码","补码","机器码"],"title":"2.1机器内的数据表示","uri":"/2.1%E6%9C%BA%E5%99%A8%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"机器内的数据表示 1.原码 表示法原码(true form)是一种计算机中对数字的二进制定点表示方法、一种直观的数据表示方法，除符号被数值化以外，数值部分仍保留着其真值的特征。 2.反码 反码通常是用来由原码求补码或者由补码求原码的过渡码，运算相对原码简单：符号位参加运算, 只需要设置加法器，但符号位的进位位需要加到最低位。例如下图 3.补码 补码相对于原码复杂，但零的表示是唯一的。补码是计算机把减法运算转化为加法运算的关键编码，补码运算简单，只需设置加法器。 4.移码 计算机中如何判断一个数是否为“机器零”有两条件，分别为当浮点数尾数为0时，不论其阶码为何值按机器零处理；另外，当浮点数阶码等于或小于它所表示的最小数时，不论尾数为何值，按机器零处理。 5.机器码举例 举例： X=+1011 原= 反= 补= 01011 X= –1011 原=11011 反=10100 补=10101 0的表示： [+0]原= 00000 [-0]原=10000 [+0]反= 00000 [-0]反=11111 [+0]补= 00000=[-0]补 参考资料 ","date":"2020-03-05","objectID":"/2.1%E6%9C%BA%E5%99%A8%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/:0:1","tags":["计算机组成原理","原码","反码","补码","机器码"],"title":"2.1机器内的数据表示","uri":"/2.1%E6%9C%BA%E5%99%A8%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA/"},{"categories":["计算机组成原理"],"content":"一、冯•诺依曼结构计算机的特点、工作原理 1 )冯•诺依曼结构计算机的特点 (1)由运算器、控制器、存储器、输人设备和输出设备等5部分组成。 (2)指令和数据以二进制形式存放在存储器中，存储器按地址访问。 (3)指令由操作码和地址码构成，并由指令控制计算机的运行。 (4)由控制器来控制程序和数据的存取及程序的执行。 2 )冯•诺依曼结构计算机的工作原理 冯•诺依曼结构计算机的工作原理是“存储程序”和“程序控制”。“存储程序”，就是将解题的步骤编成程序，然后把程序存放到计算机的存储器中。“程序控制”就是程序运行时，控制器根据逐条从主存中取出指令，控制全机相关部件执行相应的操作，完成指令的功能，直到程序中所有指令执行完成，从而实现程序应该完成的功能。 ","date":"2020-03-04","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:1","tags":["计算机组成原理","总结","练习"],"title":"第一章 计算机系统概述总结与练习","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"二、计算机系统的组成及各部分的作用 一台完整的计算机应包括硬件和软件两部分。硬件与软件结合，才能使计算机正常运行并发挥作用。因此，对计算机的理解不能仅局限于硬件部分,应该把它看作一个包含软件系统与硬件系统的完整系统。 常见的硬件及其功能如下。 (1)存储器主要功能是存放程序和数据，按地址访问。要掌握常用主存容量指标和访问对应容量主存所需要的地址线的数量。 (2)运算器：对数据进行算术运算和逻辑运算的部件。 (3)控制器：指挥协调计算机各部件工作。控制器根据指令的操作码、指令执行过程中的条件状态、时序系统等3方面的因素来产生指令执行过程中所需要的控制信号，控制指令的执行。 (4)输人设备：将信息输人到计算机的设备，如键盘、鼠标等。 (5)输出设备：将计算机运算结果转换成人或其他设备能接收并识别的外部设备。 软件系统的组成如下。一台计算机中全部程序的集合，统称为这台计算机的软件系统。软件按其功能分成应用软件和系统软件两大类。应用软件是用户为解决某种应用问题而编制的一些程序，如科学计算程序、自动控制程序、工程设计程序、数据处理程序、情报检索程序等。随着计算机的广泛应用，应用软件的种类及数量将越来越多，功能也越来越强大。系统软件用于对计算机系统的管理、调度、监视和服务等功能，其目的是方便用户，提高计算机使用效率，扩充系统的功能。操作系统、数据库系统、各类监控程序等都是常见的系统软件。 ","date":"2020-03-04","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:2","tags":["计算机组成原理","总结","练习"],"title":"第一章 计算机系统概述总结与练习","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"三、计算机系统的层次结构 (1)五级层次结构。 第1级为微程序设计级，第2级为机器语言级，第3级为操作系统级，第4级为汇编语言级，第5级为高级语言级。其中1、2级是硬件机器，是计算机系统的基础和核心，计算机的所有功能最终都由硬件来完成；第3级是面向机器的，它是为支持高层的需要而设置的；4、5级是面向应用的，它们是为程序员解决应用问题而设置的。 (2)不同层次之间的关系。 高层是低层功能的扩展，低层是高层的基础；站在不同的层次观察计算机系统，得到的概念不同。 (3)等价性。 从用户的角度来看硬件和软件在功能上是等价的，软硬件的逻辑等价性原理是计算机系统设计的重要依据。 ","date":"2020-03-04","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:3","tags":["计算机组成原理","总结","练习"],"title":"第一章 计算机系统概述总结与练习","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"四、计算机的性能指标及其应用 (1 )基本性能指标包括字长和存储容量。 (2 )与时间相关的性能指标主要包括： ①时钟周期：时钟周期是时钟频率的倒数，也称为节拍周期或T周期，是处理操作最基本的时间单位。 ②CPI是指执行每条指令所需要的平均时钟周期数。 ③MIPS用每秒钟执行完成的指令数量作为衡量计算机性能的指标。④CPU时间即一段程序的执行时间。 (3)系统的可靠性及可靠性指标。 可靠性是指系统或产品在规定的条件和规定的时间内，完成规定功能的能力。系统的可靠性成为衡量计算机系统性能的一个重要指标。 衡量计算机系统可靠性的指标包括平均无故障时间MTTR、平均故樟间隔时间MTBF和可用性。提高系统可靠性的常用方法包括避错和容错。硬件系统的抗干扰设计、软件系统的测试等都是常用的避错方法；而信息冗余(如数据备份）、部件冗余(如采用双电源、双链路、双机热备份等）是常用的容错方法。 ","date":"2020-03-04","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:4","tags":["计算机组成原理","总结","练习"],"title":"第一章 计算机系统概述总结与练习","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"五、练习 1）名词解释 摩尔定律：对集成电路 上可容纳的晶体管数目、性能和价格等发展趋势的预测 ，其主要内容是：成集电路上可容纳的晶体管数量每18个月翻一番，性能将提高一倍，而其价格将降低一半。 主存 : 计算机中存放正在运行的程序和数据的存储器，为计算机的主要工作存储器，可随机存取 。 控制器：计算机的指挥中心，它使计算机各部件自动协调地工作。 时钟周期：时钟周期是时钟频率的倒数，也称为节拍周期或T周期，是处理操作最基本的时间单位。 多核处理器： 多核处理器是指在一枚处理器中集成两个或多个完整的计算引擎 ( 内核 ) 。 字长：运算器一次运算处理的二进制位数。 存储容量 : 存储器中可存二进制信息的总量。 CPI ：指执行每条指令所需要的平均时钟周期数。 MIPS ：用每秒钟执行完成的指令数量作为衡量计算机性能的一个指标，该指标以每秒钟完成的百万指令数作为单位。 CPU 时间：计算某个任务时 CPU 实际消耗的时间，也即 CPU 真正花费在某程序上的时间。 计算机系统的层次结构：计算机系统的层次结构由多级构成，一般分成 5 级，由低到高分别是：微程序设计级，机器语言级，操作系统级，汇编语言级，高级语言级。 基准测试程序：把应用程序中使用频度最高的那那些核心程序作为评价计算机性能的标准程序。 软 / 硬件功能的等价性：从逻辑功能的角度来看，硬件和软件在完成某项功能上是相同的，称为 软 / 硬件功能是 等价的，如浮点运算既可以由软件实现，也可以由专门的硬件实现。 固件：是一种软件的固化，其目的是为了加快软件的执行速度。 可靠性：可靠性是指系统或产品在规定的条件和规定的时间内，完成规定功能的能力 。 产品可靠性定义的要素是三个 “ 规定” ：“规定条件”、“规定时间” 和 “规定功能” 。 MTTF ：平均无故障时间 ，指系统自使用以来到第一次出故障的时间间隔的期望值。 MTTR ：系统的平均修复时间。 MTBF ：平均故障间隔时间，指相邻两次故障之间的平均工作时间。 可用性：指系统在任意时刻可使用的概率，可根据 MTTF、MTTR和 MTBF等指标计算处系统的可用性。 2）冯•诺依曼型计算机的基本思想是什么？按此思想设计的计算机硬件系统应由哪些部件组成？各起什么作用？ 答：冯诺依曼型计算机的基本思想是存储程序和程序控制，其中的“存储程序”是指将解题的步骤编写成程序，然后把存储存放到计算机的内存中，而“程序控制”是指控制器读出存放在存储器中的程序并根据该程序控制全机协调工作以完成程序的功能。 根据冯诺依曼型计算机的基本思想，计算机的硬件应该由运算器、控制器、存储器、输入\\输出设备和总线组成。 各部件的作用： 运算器：对数据进行运算的部件。 存储器：存放程序和数据。 控制器：根据指令的功能控制构成计算机的各大功能部件协调工作，共同完成指令的功能。 输入设备：将外部信息输送到主机内部的设备。 输出设备：能将计算机内部的信息以不同并且相应的形式反馈给人们的设备。 总线：连接两个或多个设备（部件）的公共信息通路。 3)计算机内部有哪两股信息在流动？它们彼此有什么关系? 答：计算机中有两股信息在流动：一股是控制信息，即操作命令，它分散流向各个部件；一股是数据信息，它受控制信息的控制，从一个部件流向另一个部件，在流动的过程被相应的部件加工处理。 PS：这是第二章的内容，不知道为啥书上把它放在第一章的习题上 4)假定某计算机1和计算机2以不同的方式实现了相同的指令集 , 该指令集中共有A 、B 、C 、D 四类指令，它们在程序中所占比例分别为40% 、20% 、20% 、20% ，机器 1 和机器 2 的时钟周期为 600MHZ 和 800MHZ ，各类指令在两机器上的 CPI 如表1.5所示，求两机器的MIPS各为多少？ A B C D CPI1 2 3 4 5 CPI2 2 2 3 4 解： CPI1= 20.4+ 0.2(3+4+5)= 3.2 MIPS1= f/(CPI1 X10^6 ) = 600 10 6 /(3.2 X10^6 )=187.5 CPI2= 20.4+ 0.2(2+3+4)= 2.6 MIPS 2 = f/(CPI1 X 10^6 ) = 800 X 10^6 /(2.6 10 6 )=307.7 5) 若某程序编译后生成的目标代码由 A 、 B 、 C 、 D 四类指令组成，它们在程序中所占比例分别为 40% 、 20% 、 15% 、 25% 。已知 A 、 B 、 C 、 D 四类指令的 CPI 分别为 1 、 2 、 2 、 2 。现需要对程序进行编译优化，优化后的程序中 A 类指令条数减少了一半，而其它指令数量未发生变化。假设运行该程序的计算机 CPU 主频为 500MHZ 。完成下列各题： 优化前后程序的 CPI 各为多少 ? 优化前后程序的 MIPS 各为多少 ? 3）通过上面的计算结果你能得出什么结论？ 解： 1) 优化前： CPI=1X0.4 + 2X0.2 + 2X0.15 + 2X0.25 = 1.6 优化后：CPI= = 1X1/4 + 2X1/4 + 2X3/16 + 2X5/16 = 1.75 2 ） 优化前： MIPS = (500 X10^6 ) /(1.6 X 10^6 ) = 312.5 优化后： MIPS = (500 X10^6 ) /(1.75 X 10^6 ) = 285.7 3) 优化后， A 类指令条数减少，造成计算机的 CPI 增加， MIPS 减少。这样的优化虽然减少了 A类指令条数，却降低了程序的执行速度。 参考资料 ","date":"2020-03-04","objectID":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/:0:5","tags":["计算机组成原理","总结","练习"],"title":"第一章 计算机系统概述总结与练习","uri":"/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E6%80%BB%E7%BB%93%E4%B8%8E%E7%BB%83%E4%B9%A0/"},{"categories":["计算机组成原理"],"content":"对一台计算机的性能进行科学合理的评估是一项重点工作。计算机系统设计者要利用性能评估来对计算机中新增功能的有效性进行评价；制造商在计算机销售过程中要使用该性能指标进行宣传；计算机用户在购买计算机时要使用性能指标进行合理的选择。计算机系统性能评价一般由非时间指标（机器字长、总线宽度、主存容量与存储带宽）和非时间指标（主频f/时钟周期T , 外频、倍频、cpi、MIPS、cpu时间）决定。 ","date":"2020-03-03","objectID":"/1.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/:0:0","tags":["计算机组成原理","性能评价"],"title":"1.2计算机系统性能评价","uri":"/1.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/"},{"categories":["计算机组成原理"],"content":"时间指标 1)机器字长: 指机器一次能处理的二进制位数 机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数（整数运算即定点整数运算）。因为计算机中数的表示有定点数和浮点数之分，定点数又有定点整数和定点小数之分，这里所说的整数运算即定点整数运算。机器字长也就是运算器进行定点数运算的字长，通常也是CPU内部数据通道的宽度。 2)总线宽度：数据总线一次能并行传送的最大信息的位数 总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线。这里一般指运算器与存储器之间的数据总线位数。有些计算机内部与外部数据总线宽度不一致。 3)主存容量与存储带宽 主存容量：是指一台计算机主存所包含的存储单元总数。 存储带宽：指单位时间内与主存交换的二进制信息量，常用单位B/s（字节/秒）。(影响存储带宽的指标包括数据位宽和数据传输速率)。 ","date":"2020-03-03","objectID":"/1.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/:0:1","tags":["计算机组成原理","性能评价"],"title":"1.2计算机系统性能评价","uri":"/1.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/"},{"categories":["计算机组成原理"],"content":"非时间指标 1) 主频f/时钟周期T , 外频、倍频 主频f指CPU内核工作的时钟频率，即CPU内数字脉冲信号振荡的速率，与CPU实际的运算能力之间不是唯一的、直接关系。 时钟周期T也称节拍周期，是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。 f与T的关系互为倒数，f 越高，T就越小(f =100MHz时T=10ns，f =1GHz时T=1ns) 外频指CPU(内存)与主板之间同步的时钟频率(系统总线的工作频率)。 倍频CPU主频与外频之间的倍数。 主频= 外频×倍频 如：Pentium 4 2.4G CPU主频2400M = 133M (外频) ×18 (倍频) 2) CPI (Clock cycles Per Instruction) CPI指执行一条指令(平均)需要的时钟周期数(即T周期的个数)。有单条指令CPI 、一段程序中所有指令的CPI、指令系统CPI 等。 CPI计算方法： PS：实际上频率和IPC在真正影响CPU性能。准确的CPU性能判断标准应该是：CPU性能=IPC(CPU每一时钟周期内所执行的指令多少)×频率(MHz时钟速度)–由英特尔提出并被业界广泛认可。 [IPC:每个时钟周期内执行的指令条数(并行)] 3) MIPS (Million Instructions Per Second) 4) CPU时间 CPU时间的计算方法 问题与思考 1、某程序的目标代码主要由4类指令组成，它们在程序中所占的比例和各自的CPI如表1.2所示 | 指令类型 | CPI | 所占比例 | | ———— | —- | ——– | | 算术逻辑运算 | 1 | 60% | | 内存读写 | 2 | 18% | | 转移 | 4 | 12% | | 其他 | 8 | 10% | (1)求该程序的CPI。16 (2)若该CPU的主频为400MHz，求该机的MIPS。 解： （1）CPI = 1 X 0. 6 + 2 X 0. 18 + 4 X 0. 12 + 8 X 0. 1 = 2. 24 （2）根据公式MIPS=时钟频率/CPI*10^6 得： MIPS=(400X106)/(2. 24X 106) = 178. 6 2、假设计算机A和B是基于相同指令集设计的两种不同类型的计算机，机器A的时钟周期为2ns，某程序在机器A上运行时的C P I为3. 0。机器B的时钟周期为4ns，同一程序在机器B上运行的C PI为2,对这个程序而言，计算机A与B哪个机器更快？快多少？ 解：根据CPU时间定义：CP U时间A = CP U时钟周期八X CPIAX指令条数八=2X 3 X指令条数八 CP U时间B = CP U时钟周期8 X CPIBX指令条数1! = 4X2X指令条数B 由于是同一程序在A ,B两机器上运行，因此指令数量相同，由此得到同一程序在两机器上的CP U时间之比为 CPU 时间A/CPU时间B =6/8 =0.75 即计算机A快，且其速度约为机器B速度的1.3倍。 参考资料 ","date":"2020-03-03","objectID":"/1.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/:0:2","tags":["计算机组成原理","性能评价"],"title":"1.2计算机系统性能评价","uri":"/1.2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/"},{"categories":["计算机组成原理"],"content":"冯·诺依曼被称为“计算机之父”是20世纪最重要的数学家之一，在现代计算机、博弈论等领域的作出了重大贡献。冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。 ","date":"2020-03-02","objectID":"/1.1%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:0:0","tags":["计算机组成原理","冯·诺依曼"],"title":"1.1冯·诺依曼结构计算机工作原理及层次结构分析","uri":"/1.1%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["计算机组成原理"],"content":"冯·诺依曼计算机的硬件组成 冯诺依曼体系结构的总体硬件结构： 主机：CPU （运算器+ 控制器）、内存 外设：输入设备、输出设备、外存储器 总线：地址线、数据线、控制线 冯诺依曼体系结构的各大组成部分 1)运算器 在控制器的统一控制下，负责对数据进行加工、完成各种运算，如算术运算、逻辑运算、位移、比较等。其数据取自内存，运算结果又送往内存。 2)控制器 控制器是整个计算机的指挥控制中心，通过向其他设备（计算机中的所有硬件设备2，直接或间接）发出控制信号来控制、控制计算机，使其能自动、协调地工作。 3)存储器 计算机系统中用于保存信息的记忆设备，存放计算机中所有数据的场所。 4)输入设备 输入设备是向计算机输入数据和信息的设备。是计算机与用户或其他设备通信的桥梁。输入设备是用户和计算机系统之间进行信息交换的主要装置之一。(显示器、声卡、网卡、打印机等) 5)输入设备 是计算机硬件系统的终端设备，用于接收计算机数据的输出显示、打印、声音、控制外围设备操作等。也是把各种计算结果数据或信息以数字、字符、图像、声音等形式表现出来。(键盘、鼠标、网卡、扫描仪)等 ","date":"2020-03-02","objectID":"/1.1%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:0:1","tags":["计算机组成原理","冯·诺依曼"],"title":"1.1冯·诺依曼结构计算机工作原理及层次结构分析","uri":"/1.1%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["计算机组成原理"],"content":"计算机的层次结构 硬联逻辑级 第零级是硬联逻辑级，这是计算机的内核，由门，触发器等逻辑电路组成。 微程序级 第一级是微程序级。这级的机器语言是微指令集，程序员用微指令编写的微程序，一般是直接由硬件执行的。 传统机器级 第二级是传统机器级，这级的机器语言是该机的指令集，程序员用机器指令编写的程序可以由微程序进行解释。 操作系统级 第三级是操作系统级，从操作系统的基本功能来看，一方面它要直接管理传统机器中的软硬件资源，另一方面它又是传统机器的延伸。 汇编语言级 第四级是汇编语言级，这级的机器语言是汇编语言，完成汇编语言翻译的程序叫做汇编程序。 [1] 高级语言级 第五级是高级语言级，这级的机器语言就是各种高级语言，通常用编译程序来完成高级语言翻译的工作。 应用语言级 第六级是应用语言级，这一级是为了使计算机满足某种用途而专门设计的，因此这一级语言就是各种面向问题的应用语言。 把计算机系统按功能分为多级层次结构，就是有利于正确理解计算机系统的工作过程，明确软件，硬件在计算机系统中的地位和作用。 参考资料 ","date":"2020-03-02","objectID":"/1.1%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:0:2","tags":["计算机组成原理","冯·诺依曼"],"title":"1.1冯·诺依曼结构计算机工作原理及层次结构分析","uri":"/1.1%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["计算机组成原理"],"content":"《计算机组成原理》是电子信息工程专业大二下学期的一门核心专业基础课。它的主要内容：介绍运算器、控制器、存储器的结构、工作原理、设计方法及互连构成整机的有关技术。 ","date":"2020-03-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/:0:0","tags":["计算机组成原理"],"title":"《计算机组成原理》导学","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/"},{"categories":["计算机组成原理"],"content":"1.1为什么要学习计算机组成原理 总的来说主要有以下五点理由： ①核心专业基础课，在课程体系中承上启下的作用 ②后PC时代技术发展的迫切需求–专业地位更加凸显 ③我国信息产业发展的迫切需求 ④服务于国家战略的迫切需求 ⑤增加自身的知识深度和广度 ","date":"2020-03-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/:0:1","tags":["计算机组成原理"],"title":"《计算机组成原理》导学","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/"},{"categories":["计算机组成原理"],"content":"1.2计算机组成原理主要学什么 1.计算机系统概述 冯诺依曼结构计算机工作原理 计算机系统层次结构 计算机系统性能评价 2.数据表示 机器数及特点 定点数与浮点数据表示 数据校验基本原理 奇偶校验及其实现 CRC校验及其实现 海明校验及其实现 3.运算方法与运算器 补码加/减运算 溢出检测 补码加/减运算器设计 补码一位乘法 乘法运算器设计 补码一位除法 除法运算器设计 浮点数加减运算 4.存储系统 存储系统层次结构 主存的工作原理及数据组织 静态存储器工作原理 动态存储器工作原理 存储器扩展多体交叉存储器 Cache的基本原理 全相联映射 直接映射 组相联映射 替换算法 Cache例题选讲(一) 页式虚拟存储器的工作原理 TLB的工作原理 磁盘工作原理 RAID技术 5.指令系统 指令系统概述及指令格式 指令的寻址方式 操作数寻址方式 数据寻址方式特点对比分析 指令格式设计 MIPS指令系统简介 6.CPU CPU的组成与功能 数据通路 数据通路与总线结构 数据通路实例 指令周期 总线结构CPU指令周期 硬布线控制器 微程序控制器 微指令格式 单周期CPU 多周期CPU CPU设计 7.系统总线 总线的特征及应用 总线性能与总线事务 总线连接方式 总线仲裁和数据传输 总线标准 8.输入/输出系统 输入输出接口概述 输入输出方式 中断请求与响应 DMA 应用举例 ","date":"2020-03-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/:0:2","tags":["计算机组成原理"],"title":"《计算机组成原理》导学","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/"},{"categories":["计算机组成原理"],"content":"1.3如何学好计算机组成原理 ①三观学习视角和学习方法（构造观、系统观、工程观） ②多实践 01利用仿真软件Logisim设计学习过的硬件功能部件或系统； 02尽量在FPGA开发板上基于EDA软件实现所设计的部件或系统。 参考资料 ","date":"2020-03-01","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/:0:3","tags":["计算机组成原理"],"title":"《计算机组成原理》导学","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AF%BC%E5%AD%A6/"},{"categories":["单片机","嵌入式"],"content":" HT32F52352的资料在网上实在是太少了（相对于stm32），花了很长时间，利用的是ESK32-30501v2.1这块板子终于实现了USART串口的发生和接收，接收中断、FIFO功能。以后开发其它模块可以直接拿来就用了。 由于这块板子相当于已经集成了CH340TTL转usb模块，无需外接CH340就可以在电脑端接收和发生数据。（注意：板子上中间的跳帽需跳到左边才能实现此功能）这块mcu一共有两组USART串口（USART0和USART1）在数据手册可以看到，可用于TX,RX的口却有非常多个。 USART通常有三种模式接收方式，分别是查询方式、中断方式、中断＋FIFO方式。 查询方式就是代码不断的去查询寄存器状态。这种方式的好处就是实时性比较高，缺点就是太占用单片机的性能了，毕竟单片机也不单只是去查usart串口有无数据吧。 中断方式比较常用，这种方式的好处就是实时性比较高，实用于实时性很高的场景，缺点也很明显，那就是比较占用单片机性能。 中断＋FIFO方式则是对中断的补充，使用FIFO，可以在连续接收若干个数据后才产生一次中断，然后一起进行处理。这样可以提高接收效率，避免频繁进中断，适用于大数据传输。 但是使用FIFO接收多字节数据进中断不好的地方是实时性会受到一定的影响，对某些实时性要求高的场合，比如说要求UART收到某个特定字符就立刻停止发送数据这样一个场合，使用FIFO每多个字节进一次中断就不合适了。 所以说使用FIFO好处是1、避免频繁进中断，提高吞吐率 2、避免数据因没有及时处理而丢失。不好的地方是实时性受影响。 在现实中具体用那种方式，需要按照需求来确定。以下是HT32F52352的实现代码。 usart.c #include \"usart.h\"#include \"ht32f5xxxx_gpio.h\" /**************************实现函数******************************************** 函数说明：配置usart串口 *******************************************************************************/ void USART_Configuration(void) { USART_InitTypeDef USART_InitStructure; AFIO_GPxConfig(USART_GPIO_GROUP, USART_TX_PIN, AFIO_FUN_USART_UART); AFIO_GPxConfig(USART_GPIO_GROUP, USART_RX_PIN, AFIO_FUN_USART_UART); /* 波特率： 115200 长度： 8bits 停止位： 1位 校验位： 无 模式： 正常模式 */ USART_InitStructure.USART_BaudRate = 115200; USART_InitStructure.USART_WordLength = USART_WORDLENGTH_8B; USART_InitStructure.USART_StopBits = USART_STOPBITS_1; USART_InitStructure.USART_Parity = USART_PARITY_NO; USART_InitStructure.USART_Mode = USART_MODE_NORMAL; USART_Init(COM1_PORT, \u0026USART_InitStructure); // 使能 COM1_PORT 发送和接收 USART_TxCmd(COM1_PORT, ENABLE); USART_RxCmd(COM1_PORT, ENABLE); //中断设置 NVIC_EnableIRQ(COM1_IRQn); USART_IntConfig(COM1_PORT, USART_FLAG_RXDR , ENABLE); USART_IntConfig(COM1_PORT, USART_FLAG_TXDE , ENABLE); /* 设置FIFO接收等级 */ USART_RXTLConfig(COM1_PORT, USART_RXTL_04); } /**************************实现函数******************************************** 函数说明：接收中断服务函数 *******************************************************************************/ void COM1_IRQHandler(void) { u8 data; if( USART_GetFlagStatus(COM1_PORT, USART_FLAG_RXDR ) ) //接收中断 { data = USART_ReceiveData(COM1_PORT); //读取接收到的数据 printf(\"data = %c\\n\",data); //把收到的数据发送回电脑 } } /**************************实现函数******************************************** 函数说明：FIFO *******************************************************************************/ void USART_Tx(const char* TxBuffer, u32 length) { int i; for (i = 0; i \u003c length; i++) { while (!USART_GetFlagStatus(COM1_PORT, USART_FLAG_TXC)); USART_SendData(COM1_PORT, TxBuffer[i]); } } /**************************实现函数******************************************** 函数说明：发送一个字节 *******************************************************************************/ void Usart_Sendbyte(HT_USART_TypeDef* USARTx, u8 data) { USART_SendData(USARTx, data); while (USART_GetFlagStatus(USARTx, USART_FLAG_TXDE) == RESET); } /**************************实现函数******************************************** 函数说明：发送数组 *******************************************************************************/ void Usart_SendArray(HT_USART_TypeDef* USARTx, u8 *array,u8 num) { u8 i; for( i = 0;i \u003c num;i++) { Usart_Sendbyte(USARTx,*array); array++; } } /**************************实现函数******************************************** 函数说明：发送字符串 *******************************************************************************/ void Usart_SendStr(HT_USART_TypeDef* USARTx, uint8_t *str) { uint8_t i; for(i = 0;str[i] != '\\0';i++) { Usart_Sendbyte(USARTx,str[i]); } } usart.h #ifndef __USART_H #define __USART_H #include \"ht32f5xxxx_usart.h\"#include \"sys.h\"#define USART_GPIO_GROUP (GPIO_PA) #define USART_TX_PIN (GPIO_PIN_4) #define USART_RX_PIN (GPIO_PIN_5) #define USART_AFIO_MODE (AFIO_FUN_USART_UART) //默认模式：AFIO_MODE_DEFAULT ，AFIO_MODE_1~15对应模式1~15 #define COM1_PORT (HT_USART1) #define COM1_IRQn (USART0_IRQn) void USART_Configuration(void); void COM1_IRQHandler(void); void Usart_Sendbyte(HT_USART_TypeDef* USARTx, u8 data); void Usart_SendArray(HT_USART_TypeDef* USARTx, u8 *array,u8 num); v","date":"2020-02-21","objectID":"/%E5%8D%95%E7%89%87%E6%9C%BA4-ht32f5232%E5%AD%A6%E4%B9%A0%E4%B9%8Busart%E4%B8%B2%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E4%BB%A5%E5%8F%8A%E5%AF%B9%E4%B8%89%E7%A7%8D%E6%8E%A5%E6%94%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%9D%E8%80%83/:0:0","tags":["单片机","HT32F5232","合泰单片机","32位单片机","USART","串口通讯"],"title":"HT32F5232学习之USART串口实现发送接收以及对三种接收方式的思考","uri":"/%E5%8D%95%E7%89%87%E6%9C%BA4-ht32f5232%E5%AD%A6%E4%B9%A0%E4%B9%8Busart%E4%B8%B2%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E4%BB%A5%E5%8F%8A%E5%AF%B9%E4%B8%89%E7%A7%8D%E6%8E%A5%E6%94%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["单片机","嵌入式"],"content":" 在上一篇文章中，我利用了延时函数实现了按键软件去抖的方法，现在利用系统的滴答定时器来实现精准延时的。在这块ESK32-30501v2.1的板子上有一个外部8MHZ高速晶振 (HSE)，它连接的是PB13和PB14。利用它作为时钟源，编写出精准的延时函数就是本篇文章的目的。delay.c #include \"ht32_cm0plus_misc.h\"#include \"delay.h\"//mS微秒级延时程序 void delay_us(u32 us) { u32 i; SYSTICK_ClockSourceConfig(SYSTICK_SRC_STCLK); //选择外部参考时钟作为SysTick时钟源。8MHZ SYSTICK_SetReloadValue(SystemCoreClock / 8 / 1000000); // 重装计数初值 SYSTICK_IntConfig(DISABLE); // 是否开启中断 SYSTICK_CounterCmd(SYSTICK_COUNTER_CLEAR); //清空定时器 SYSTICK_CounterCmd(SYSTICK_COUNTER_ENABLE); //使能 for( i = 0;i \u003c us;i++ ) { while( !( (SysTick-\u003eCTRL) \u0026 (1\u003c\u003c16) ) ); } SYSTICK_CounterCmd(SYSTICK_COUNTER_DISABLE); //关闭 SYSTICK_CounterCmd(SYSTICK_COUNTER_CLEAR); //复位清零 } void delay_ms(u16 ms){ //mS毫秒级延时程序 while( ms-- != 0){ delay_us(1000); //调用1000微秒的延时 } } void delay_s(u16 s){ //S秒级延时程序 while( s-- != 0){ delay_ms(1000); //调用1000毫秒的延时 } } 毫秒级函数的实现方法就是调用1000次微秒级函数,秒级函数则是调用1000次毫秒级函数 delay.h #ifndef __DELAY_H #define __DELAY_H #include \"ht32_cm0plus_misc.h\"void delay_s(u16 s); void delay_ms(u16 ms); void delay_us(u32 us); #endif main() #include \"ht32.h\"#include \"sys.h\"#include \"led.h\"#include \"delay.h\"#include \"key.h\"int main() { u8 MENU; u16 t,i; //初始化程序 RCC_Configuration(); //时钟设置 LED_Init(); //设置变量的初始值 MENU = 0; t = 1; //主循环 while(1){ //菜单0 if(MENU == 0){ //变亮循环 for(i = 0; i \u003c 2; i++){ GPIO_WriteOutBits(HT_GPIOC,LED1_PIN|LED2_PIN,SET); delay_us(t); //延时 GPIO_WriteOutBits(HT_GPIOC,LED1_PIN|LED2_PIN,RESET); delay_us(1001-t); //延时 } t++; if(t==1000){ MENU = 1; } } //菜单1 if(MENU == 1){ //变暗循环 for(i = 0; i \u003c 2; i++){ GPIO_WriteOutBits(HT_GPIOC,LED1_PIN|LED2_PIN,SET); delay_us(t); //延时 GPIO_WriteOutBits(HT_GPIOC,LED1_PIN|LED2_PIN,RESET); delay_us(1001-t); //延时 } t--; if(t==1){ MENU = 0; } } } } 当时钟源被设定为8MHz时,如果要产生1ms 时间基准。那么他的计算方法就是(8M/8/1000) = 1ms.这里利用了延时函数实现了LED呼吸灯的效果 . 配置环境参考 ","date":"2020-02-15","objectID":"/%E5%8D%95%E7%89%87%E6%9C%BA3-ht32f5232%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%A9%E7%94%A8dealy%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%91%BC%E5%90%B8%E7%81%AF%E6%95%88%E6%9E%9C/:0:0","tags":["单片机","HT32F5232","合泰单片机","32位单片机","delay","滴答定时器"],"title":"HT32F5232单片机学习之利用dealy延时函数实现呼吸灯效果","uri":"/%E5%8D%95%E7%89%87%E6%9C%BA3-ht32f5232%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%A9%E7%94%A8dealy%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%91%BC%E5%90%B8%E7%81%AF%E6%95%88%E6%9E%9C/"},{"categories":["单片机","嵌入式"],"content":" 学会了如何点亮LED灯，那么接下来的就是如何把手中的这颗LED灯玩出新花样，在上一篇文章的基础上优化了第一次写代码的不足，加入了四种按键控制led灯 的方法。根据电路原理图可知，按键一端分别连接PA0和PA1，另一端连接GND。也就是说当PA0或PA1按下的时候，按键与GND导通，使得IO端口短接到GND，只要我们把IO口设为高电平然后通过程序读取IO端口的电平状态就能判断按键状态，如果为低电平则表示按键为按下状态，如果为高电平则按键为松开状态这种连接方式是最经典的按键连接方式。 key.c #include \"key.h\" void KEY_Init(void){ HT_GPIO_TypeDef* GPIO_GROUP; //枚举 GPIO_GROUP = HT_GPIOA; //以后只要修改这里即可 AFIO_GPxConfig(KEY_GPIO_GROUP, KEY1_PIN|KEY2_PIN, KEY_AFIO_MODE); //配置AFIO模式 GPIO_InputConfig(GPIO_GROUP,KEY1_PIN|KEY2_PIN, ENABLE); //输入使能函数，此函数可实现GPIO口变为输入模式，上拉电阻，默认电流。因此这个函数可替换以下三个被注释的函数 // GPIO_DirectionConfig(GPIO_GROUP,KEY1_PIN|KEY2_PIN, GPIO_DIR_IN); //配置GPIO模式：GPIO_DIR_OUT输出orGPIO_DIR_IN输入 */ // GPIO_PullResistorConfig(GPIO_GROUP,KEY1_PIN|KEY2_PIN, GPIO_PR_UP); //上拉电阻，使IO口为高电平 // GPIO_DriveConfig(GPIO_GROUP,LED1_PIN|LED2_PIN, GPIO_DV_4MA); //选择指定GPIO引脚的驱动电流，可选GPIO_DV_4/8/12/16MA } GPIO_InputConfig()这个函数可以取代GPIO_DirectionConfig（） GPIO_PullResistorConfig（）GPIO_DriveConfig（）这个三个函数的功能，此函数可实现GPIO口变为输入模式，上拉电阻，默认电流。 key.h #ifndef __KEY_H #define __KEY_H #include \"sys.h\" #define KEY_GPIO_GROUP (GPIO_PA) #define KEY1_PIN (GPIO_PIN_0) #define KEY2_PIN (GPIO_PIN_1) #define KEY_AFIO_MODE (AFIO_MODE_DEFAULT) //默认模式：AFIO_MODE_DEFAULT ，AFIO_MODE_1~15对应模式1~15 void KEY_Init(void);//初始化 #endif led.c #include \"led.h\" void LED_Init() //led初始化函数 { HT_GPIO_TypeDef* GPIO_GROUP; //枚举 GPIO_GROUP = HT_GPIOC; //以后只要修改这里即可 AFIO_GPxConfig(LED_GPIO_GROUP, LED1_PIN|LED2_PIN, LED_AFIO_MODE); //配置AFIO模式 GPIO_DirectionConfig(GPIO_GROUP,LED1_PIN|LED2_PIN, GPIO_DIR_OUT); //配置GPIO模式：GPIO_DIR_OUT输出orGPIO_DIR_IN输入 */ GPIO_PullResistorConfig(GPIO_GROUP,LED1_PIN|LED2_PIN, GPIO_PR_DISABLE); //上拉电阻，使IO口为高电平 GPIO_DriveConfig(GPIO_GROUP,LED1_PIN|LED2_PIN, GPIO_DV_8MA); //选择指定GPIO引脚的驱动电流，可选GPIO_DV_4/8/12/16MA } led.h #ifndef _LED_H #define _LED_H #include \"sys.h\" #define LED_GPIO_GROUP (GPIO_PC) #define LED1_PIN (GPIO_PIN_14) #define LED2_PIN (GPIO_PIN_15) #define LED_AFIO_MODE (AFIO_MODE_DEFAULT) //默认模式：AFIO_MODE_DEFAULT ，AFIO_MODE_1~15对应模式1~15 void LED_Init(void); #endif sys.c #include \"sys.h\" void NVIC_Configuration(void){ //嵌套中断向量控制器 的设置 //NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 } void RCC_Configuration(void){ //RCC时钟设置 CKCU_PeripClockConfig_TypeDef CCLOCK = {{0}};//不开启外设时钟相应功能无法使用 CCLOCK.Bit.PA = 1;//开启PA时钟 CCLOCK.Bit.PB = 0;//开启PB时钟 CCLOCK.Bit.PC = 1;//开启PC时钟 CCLOCK.Bit.PD = 0;//开启PD时钟 CCLOCK.Bit.AFIO = 1;//开启复用功能时钟 CKCU_PeripClockConfig(CCLOCK, ENABLE);//使能时钟 } sys.h #ifndef __SYS_H #define __SYS_H #include \"ht32f5xxxx_01.h\" void NVIC_Configuration(void); //嵌套中断控制器的设置 void RCC_Configuration(void); //RCC时钟类的设置 #endif main() int main (void){//主程序 u8 a; //定义变量 //初始化程序 RCC_Configuration(); //时钟设置 LED_Init();//LED初始化 KEY_Init();//按键初始化 //主循环 while(1){ //示例1：无锁存 if(GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)){ //读按键接口的电平 GPIO_WriteOutBits(HT_GPIOC,LED1_PIN,RESET); //LED灯亮 }else{ GPIO_WriteOutBits(HT_GPIOC,LED1_PIN,SET); //LED灯灭 } //示例2：无锁存 GPIO_WriteOutBits(HT_GPIOC,LED1_PIN,GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)); //示例3：有锁存 if(!GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)){ //读按键接口的电平 delay_ms(20); //延时去抖动 if(!GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)){ //读按键接口的电平 GPIO_WriteOutBits(HT_GPIOC,LED1_PIN,(1-GPIO_ReadOutBit (HT_GPIOC,LED1_PIN))); //LED取反 while(!GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)); //等待按键松开 } } //示例4：有锁存 if(!GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)){ //读按键接口的电平 delay_ms(20); //延时20ms去抖动 if(!GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)){ //读按键接口的电平 //在2个LED上显示二进制加法 a++; //变量加1 if(a\u003e3){ //当变量大于3时清0 a=0; } GPIO_SetOutBits (HT_GPIOC,LED1_PIN); //直接数值操作将变量值写入LED（LED在GPIOB组的PB0和PB1上） while(!GPIO_ReadInBit(KEY_GPIO_GROUP,KEY1_PIN)); //等待按键松开 } } } } 代码中的两次判断延时20ms是为了按键去抖动，这些都是非常成熟的去抖方法了，这里就不再多说。本人在学习stm32时，是杜洋老师教的，上面四种方式点亮led灯也是他教的，受他影响比较大，习惯性区块化编程，在上面示例三中会发现，编译器会发生警告 ..\\User\\main.c(83): warning: #188-D: enumerated type mixed with another type GPIO_WriteOutBits(HT_GPIOC,LED1_PIN,(1-GPIO_ReadOutBit (HT_GPIOC,LED1_PIN))); //LED取反 ..\\User\\main.c: 1 warning, 0 errors 这是由于GPIO_ReadOutBi","date":"2020-02-07","objectID":"/%E5%8D%95%E7%89%87%E6%9C%BA2-ht32f5232%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6led%E7%81%AF-%E5%89%AF%E6%9C%AC/:0:0","tags":["单片机","HT32F5232","合泰单片机","32位单片机","IO控制","按键去抖","软件去抖"],"title":"HT32F5232单片机学习之四种方法实现按键控制LED灯","uri":"/%E5%8D%95%E7%89%87%E6%9C%BA2-ht32f5232%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6led%E7%81%AF-%E5%89%AF%E6%9C%AC/"},{"categories":["单片机","嵌入式"],"content":" 因为疫情的原因，今年在家实在是太无聊了，突然想起自己去年报名参加了个合泰杯比赛，本人也是菜鸟一个，之前从未接触过合泰的单片机，刚好手头上有一块HT32F52352的开发板，型号是ESK32-30501U2.1。上一届师兄扔在实验室里，我捡回来的，刚好也就把它带了回家。 对于学习一款单片机，最开始的任务配置完开发环境后，第一件事就是点亮LED了。 关于这款单片机的资料在网上少之又少，在网上找了大量的资料，本着能不自己造轮子绝不自己造轮子的原则，终于完成了隆重的点灯仪式。 由原理图可知，控制这两个LED灯的分别是PC14和PC15这两个脚，所以我们只要控制这两个口就能实现led的亮灭了。 LED.H #ifndef _LED_H #define _LED_H #include \"ht32f5xxxx_01.h\" #define LED_GPIO_GROUP (GPIO_PC) #define LED1_PIN (GPIO_PIN_14) #define LED2_PIN (GPIO_PIN_15) #define LED_AFIO_MODE (AFIO_FUN_GPIO) void LED_Init(void); #endif LED.C #include \"led.h\" static void LED_CKCU_Config() //配置时钟 { CKCU_PeripClockConfig_TypeDef CCLOCK = {{0}};//不开启外设时钟相应功能无法使用 CCLOCK.Bit.PC = 1;//开启PC时钟 CCLOCK.Bit.AFIO = 1;//开启复用功能时钟 CKCU_PeripClockConfig(CCLOCK, ENABLE);//使能时钟 } static void LED_GPIO_Config() //配置GPIO口，使用ht32f5xxxx_gpio.c里的库函数配置IO功能 { HT_GPIO_TypeDef* GPIOgroup; GPIOgroup = HT_GPIOC; AFIO_GPxConfig(LED_GPIO_GROUP, LED1_PIN|LED2_PIN, LED_AFIO_MODE); //配置GPIO模式：AFIO_MODE_DEFAULT 默认，AFIO_MODE_1~15模式1~15 GPIO_DirectionConfig(GPIOgroup,LED1_PIN|LED2_PIN, GPIO_DIR_OUT); //配置GPIO引脚的方向：GPIO_DIR_OUT输出orGPIO_DIR_IN输入 */ GPIO_PullResistorConfig(GPIOgroup,LED1_PIN|LED2_PIN, GPIO_PR_DISABLE);//配置指定GPIO引脚的上下拉电阻。GPIO_PR_UP 带内部上拉电阻的引脚GPIO_PR_DOWN 带内部上拉电阻的引脚 GPIO_PR_DISABLE 没有拉电阻的引脚。 GPIO_DriveConfig(GPIOgroup,LED1_PIN|LED2_PIN, GPIO_DV_8MA); //选择指定GPIO引脚的驱动电流，可选GPIO_DV_4/8/12/16MA } void LED_Init() //led初始化函数 { LED_CKCU_Config(); LED_GPIO_Config(); } main.c #include \"ht32.h\"#include \"ht32_board.h\"#include \"led.h\"#include \"delay.h\"int main() { LED_Init(); while(1){ GPIO_WriteOutBits(HT_GPIOC,LED1_PIN,SET); GPIO_WriteOutBits(HT_GPIOC,LED2_PIN,RESET); delay_s(1); GPIO_WriteOutBits(HT_GPIOC,LED1_PIN,RESET); GPIO_WriteOutBits(HT_GPIOC,LED2_PIN,SET); delay_s(1); } } 编译之前，记得设置好以下参数 最后看下效果。。。 点灯仪式正式完成，欢迎大家一起交流学习！ 配置环境参考 ","date":"2020-02-04","objectID":"/%E5%8D%95%E7%89%87%E6%9C%BA1-ht32f5232%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%82%B9%E4%BA%AEled/:0:0","tags":["单片机","HT32F5232","合泰单片机","32位单片机","点亮LED"],"title":"HT32F5232单片机学习之点亮LED","uri":"/%E5%8D%95%E7%89%87%E6%9C%BA1-ht32f5232%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%82%B9%E4%BA%AEled/"},{"categories":["C语言程序设计"],"content":" 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"0001-01-01","objectID":"/0%E6%A8%A1%E6%9D%BF/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"","uri":"/0%E6%A8%A1%E6%9D%BF/"},{"categories":["C语言程序设计"],"content":" C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 #include \"stdio.h\"main() { int a[6]={1,2,3}; printf(\"栈区-地址 a[0]：%p\\n\", \u0026a[0]); printf(\"栈区-地址 a[1]：%p\\n\", \u0026a[1]); printf(\"栈区-地址 a[2]：%p\\n\", \u0026a[2]); } 编译运行输出结果： 栈区-地址 a[0]：000000000062FDF0 栈区-地址 a[1]：000000000062FDF4 栈区-地址 a[2]：000000000062FDF8 ","date":"2018-10-23","objectID":"/23c-%E6%95%B0%E7%BB%84/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 数组","uri":"/23c-%E6%95%B0%E7%BB%84/"},{"categories":["C语言程序设计"],"content":"声明数组 使用一个数组之前必须要进行声明。 type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。 比如 int laohuang[10] 现在laohuang是一个可用的数组，可以容纳 10 个类型为 int 的数字。 ","date":"2018-10-23","objectID":"/23c-%E6%95%B0%E7%BB%84/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 数组","uri":"/23c-%E6%95%B0%E7%BB%84/"},{"categories":["C语言程序设计"],"content":"初始化数组 int laohuang[5] = {1,2,3,4,5}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 中指定的元素数目。 如果省略掉[]里面的数字，则这个数组的大小为初始化时元素的大小。但如果强行加上去一个元素，这数组的大小还是初始时元素的大小。 #include \"stdio.h\"main() { int a[]={1}; int i =1; int b[3]={1,2}; printf(\"Asize1 = %d,Bsize1 = %d\\n\",sizeof(a),sizeof(b)); a[1] = 4;//给数组a添加一个元素 printf(\"%d,size2 = %d\",b[2],sizeof(a)); } Asize1 = 4,Bsize1 = 12 0,size2 = 4 这样做会导致数组越界！ 如果一个数组[]定义了大小，初始化时并未全部初始化，但在内存空间中已经占用了初始时[]设定的大小，当赋值的元素少于数组总体元素的时候，不同类型剩余的元素自动初始化值说明如下： 对于 short、int、long，就是整数 0； 对于 char，就是字符 ‘\\0’； 对于 float、double，就是小数 0.0。 数组初始化技巧: 将元素全部置零 {0}。比如double arr[10] = {0};那么arr的所有元素都是0.000000了 #include \"stdio.h\"int main(void){ double a[5]={0}; int i = 0; for(i=0;i\u003c5;i++){ printf(\"%lf\\n\",a[i]); } } 输出结果： 0.000000 0.000000 0.000000 0.000000 0.000000 ","date":"2018-10-23","objectID":"/23c-%E6%95%B0%E7%BB%84/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 数组","uri":"/23c-%E6%95%B0%E7%BB%84/"},{"categories":["C语言程序设计"],"content":"访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; 上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： #include \u003cstdio.h\u003e int main () { int n[ 10 ]; /* n 是一个包含 10 个整数的数组 */ int i,j; /* 初始化数组元素 */ for ( i = 0; i \u003c 10; i++ ) { n[ i ] = i + 100; /* 设置元素 i 为 i + 100 */ } /* 输出数组中每个元素的值 */ for (j = 0; j \u003c 10; j++ ) { printf(\"Element[%d] = %d\\n\", j, n[j] ); } return 0; } 编译运行结果： Element[0] = 100 Element[1] = 101 Element[2] = 102 Element[3] = 103 Element[4] = 104 Element[5] = 105 Element[6] = 106 Element[7] = 107 Element[8] = 108 Element[9] = 109 ","date":"2018-10-23","objectID":"/23c-%E6%95%B0%E7%BB%84/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 数组","uri":"/23c-%E6%95%B0%E7%BB%84/"},{"categories":["C语言程序设计"],"content":"判断数组大小 在我们没有明确数组的元素个数时，在程序中想知道数组单元个数可以使用 sizeof(a)/sizeof(a[0]), sizeof(a) 是得到数组 a 的大小，sizeof(a[0]) 是得到数组 a 中单个元素的大小（因此可以不必要是a[0],a[i]都行） #include\u003cstdio.h\u003e int main(int argc,char *grgv[]) { int a[]={1,2,3,4,5}; int b; b=sizeof(a)/sizeof(a[0]); printf(\"数组元素个数为：%d\",b); return 0; } 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-23","objectID":"/23c-%E6%95%B0%E7%BB%84/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 数组","uri":"/23c-%E6%95%B0%E7%BB%84/"},{"categories":["C语言程序设计"],"content":" 值传递 void Exchg1(int x, int y) { int tmp; tmp = x; x = y; y = tmp; printf(\"x = %d, y = %d\\n\", x, y); } main() { int a = 4,b = 6; Exchg1(a, b); printf(\"a = %d, b = %d\\n\", a, b); return(0); } 输出结果： x = 6，y = 4 a = 4，b = 6 函数在调用时是隐含地把实参a、b 的值分别赋值给了x、y，之后在你写的Exchg1函数体内再也没有对a、b进行任何的操作了。交换的只是x、y变量。并不是a、b。因此a、b的值没有改变，函数只是把a、b的值通过赋值传递给了x、y，函数里头操作的只是x、y的值并不是a、b的值。 指针传递 void Exchg2(int *px, int *py) { int tmp = *px; *px = *py; *py = tmp; printf(\"*px = %d, *py = %d.\\n\", *px, *py); } main() { int a = 4; int b = 6; Exchg2(\u0026a, \u0026b); printf(\"a = %d, b = %d.\\n\", a, b); return(0); } 输出结果： *px = 6, *py = 4 a = 6, b = 4 指针px、py的值已经分别是a、b变量的地址值了。接下来，对px、py的操作当然也就是对a、b变量本身的操作了。所以函数里头的交换就是对a、b值的交换了，这就是所谓的地址传递（传递a、b的地址给了px、py） 引用传递 void Exchg3(int \u0026x, int \u0026y) { int tmp = x; x = y; y = tmp; printf(\"x = %d,y = %d\\n\", x, y); } main() { int a = 4; int b = 6; Exchg3(a, b); printf(\"a = %d, b = %d\\n\", a, b); return(0); } 输出结果： x = 6, y = 4. a = 6, b = 4 \u0026在c语言中是取地址符号，调用Exchg3时函数会将a、b 分别代替了x、y，我们称：x、y分别引用了a、b变量。这样函数里头操作的其实就是实参a、b本身，也就是说函数里是可以直接修改到a、b的值。 注：严格来说，C语言中是没有引用传递，这是C++中语言特性，因此在.c文件中使用引用传递会导致程序编译出错。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-22","objectID":"/22%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"关于函数参数传递常用的三种方式","uri":"/22%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["C语言程序设计"],"content":" 根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。 内部函数 如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即 static 类型名 函数名 （形参表） 例如，函数的首行： static int max(int a,int b) 内部函数又称静态函数。使用内部函数，可以使函数的作用域只局限于所在文件。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。 外部函数 如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。 如函数首部可以为 extern int max (int a,int b) C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。 在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。 实例 以下实例通过多个文件的函数实现输入一串字符串，然后删除指定的字符： file1.c(文件1) #include \u003cstdio.h\u003e static void delete_string(char str[],char ch); int main() { extern void enter(char str[]); // 对函数的声明 extern void print(char str[]); // 对函数的声明 char c,str[100]; enter(str); scanf(\"%c\",\u0026c); delete_string(str,c); print(str); return 0; } static void delete_string(char str[],char ch)//内部函数 { int i,j; for(i=j=0;str[i]!='\\0';i++) if(str[i]!=ch) str[j++]=str[i]; str[j]='\\0'; } file2.c(文件2) #include \u003cstdio.h\u003e void enter(char str[100]) // 定义外部函数 enter { fgets(str, 100, stdin); // 向字符数组输入字符串 } file3.c(文件3) #include \u003cstdio.h\u003e void print(char str[]) // 定义外部函数 print { printf(\"%s\\n\",str); } 输入字符串\"abcdef”，给字符数组 str，在输入要删去的字符’d’。 运行结果: $ gcc file1.c file2.c file3.c $ ./a.out abcdef # 输入的字符串 d # 要删除的字符 abcef # 删除后的字符串 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-21","objectID":"/21%E5%85%B3%E4%BA%8E%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"关于内部函数和外部函数","uri":"/21%E5%85%B3%E4%BA%8E%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0/"},{"categories":["C语言程序设计"],"content":"什么是函数 函数是一段可以重复使用的代码，用来独立地完成某个功能，它可以接收用户传递的数据，也可以不接收。接收用户数据的函数在定义时要指明参数，不接收用户数据的不需要指明，根据这一点可以将函数分为有参函数和无参函数。 函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 return_type function_name(parameter list) { body of the function } 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 ","date":"2018-10-20","objectID":"/20c-%E5%87%BD%E6%95%B0/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 函数","uri":"/20c-%E5%87%BD%E6%95%B0/"},{"categories":["C语言程序设计"],"content":"函数声明 int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。 在main（）函数调用其它函数之前，必须要进行函数声明或将调用的函数写在main（）函数前，否则编译会出错 ","date":"2018-10-20","objectID":"/20c-%E5%87%BD%E6%95%B0/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 函数","uri":"/20c-%E5%87%BD%E6%95%B0/"},{"categories":["C语言程序设计"],"content":"函数参数 形参（形式参数） 在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。 实参（实际参数） 函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。 形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。 总的来说就是函数定义时给出的参数称为形式参数，简称形参；函数调用时给出的参数（也就是传递的数据）称为实际参数，简称实参。函数调用时，将实参的值传递给形参，相当于一次赋值操作。 原则上讲，实参的类型和数目要与形参保持一致。如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型，例如将 int 类型的实参传递给 float 类型的形参就会发生自动类型转换。 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。 实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。 函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参。 ","date":"2018-10-20","objectID":"/20c-%E5%87%BD%E6%95%B0/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 函数","uri":"/20c-%E5%87%BD%E6%95%B0/"},{"categories":["C语言程序设计"],"content":"函数返回值 函数的返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果通过 return 语句返回。 为了使程序有良好的可读性并减少出错， 凡不要求返回值的函数都应定义为 void 类型。 return 语句可以有多个，可以出现在函数体的任意位置，但是每次调用函数只能有一个 return 语句被执行，所以只有一个返回值。 函数一旦遇到 return 语句就立即返回，后面的所有语句都不会被执行到了。从这个角度看，return 语句还有强制结束函数执行的作用。 return 语句是提前结束函数的唯一办法。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-20","objectID":"/20c-%E5%87%BD%E6%95%B0/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 函数","uri":"/20c-%E5%87%BD%E6%95%B0/"},{"categories":["C语言程序设计"],"content":" 判断结构 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"if else 通常情况： C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。 if(判断条件){ 语句块1 }else{ 语句块2 } 由于if else 语句可以根据不同的情况执行不同的代码，所以也叫分支结构或选择结构。 在 if 语句中，判断条件必须用括号括起来。 有时候，可以只使用if，而不一定使用else。 if(判断条件)后不能加；分号，初学者最容易错的就是这里。 if（判断条件）后的第一条语句可不加{}，但建议养成好习惯，加上{}，即使只有一条语句。 语句块由{ }包围，但要注意的是在}之后不需要再加分号;（当然加上也没错）。 多个if else语句 if(判断条件1){ 语句块1 } else if(判断条件2){ 语句块2 }else if(判断条件3){ 语句块3 }else if(判断条件m){ 语句块m }else{ 语句块n } 意思是，从上到下依次检测判断条件，当某个判断条件成立时，则执行其对应的语句块，然后跳到整个 if else 语句之外继续执行其他代码。如果所有判断条件都不成立，则执行语句块n，然后继续执行后续代码。 也就是说，一旦遇到能够成立的判断条件，则不再执行其他的语句块，所以最终只能有一个语句块被执行。 if else嵌套时 C语言规定，else 总是与它前面最近的 if 配对 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"? : 运算符(三元运算符) 表达式1 ? 表达式2 : 表达式3 条件运算符是C语言中唯一的一个三目运算符，其求值规则为：如果表达式1的值为真，则以表达式2 的值作为整个条件表达式的值，否则以表达式3的值作为整个条件表达式的值。条件表达式通常用于赋值语句之中。 #include\u003cstdio.h\u003e int main() { int num; printf(\"输入一个数字 : \"); scanf(\"%d\",\u0026num); (num%2==0)?printf(\"偶数\"):printf(\"奇数\"); } 选择 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"switch case C语言虽然没有限制 if else 能够处理的分支数量，但当分支过多时，用 if else 处理会不太方便，而且容易出现 if else 配对出错的情况。例如，输入一个整数，输出该整数对应的星期几的英文表示： #include \u003cstdio.h\u003eint main(){ int a; printf(\"Input integer number:\"); scanf(\"%d\",\u0026a); switch(a){ case 1: printf(\"Monday\\n\"); break; case 2: printf(\"Tuesday\\n\"); break; case 3: printf(\"Wednesday\\n\"); break; case 4: printf(\"Thursday\\n\"); break; case 5: printf(\"Friday\\n\"); break; case 6: printf(\"Saturday\\n\"); break; case 7: printf(\"Sunday\\n\"); break; default:printf(\"error\\n\"); break; } return 0; } case可以理解为一个站点，程序选择了这个站点，从这个站点执行，如果没有break，程序会一直执行下去，直到遇见break。例如 switch(1){ case 1: printf(\"1\\n\"); case 2: printf(\"2\\n\"); case 3: printf(\"3\\n\"); break; case 4: printf(\"Thursday\\n\"); break; 1 2 3 default由于 default 是最后一个分支，匹配后不会再执行其他分支，所以也可以不添加break;语句 default 不是必须的。当没有 default 时，如果所有 case 都匹配失败，那么就什么都不执行。 break 是C语言中的一个关键字，专门用于跳出 switch 语句。所谓“跳出”，是指一旦遇到 break，就不再执行 switch 中的任何语句，包括当前分支中的语句和其他分支中的语句；也就是说，整个 switch 执行结束了，接着会执行整个 switch 后面的代码。 循环 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"while 循环 当给定条件为真时（非0），重复语句或语句组。它会在执行循环主体之前测试条件。 while(表达式){ 语句块; } {}后面可不加；，加了也没所谓。 关于while死循环 while （1）循环会一直执行下去，永不结束，成为“死循环”。 #include \u003cstdio.h\u003e int main(){ while(1){ printf(\"1\"); } return 0; } 死循环可以用break；跳出。 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"do-while循环 do{ 语句块; }while(表达式); 与while相同，但do while是先做一次do里面的程序，然后再判断。 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:5","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"for循环 多次执行一个语句序列，简化管理循环变量的代码。 for ( init; condition; increment ) { statement(s); } init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。 #include \"stdio.h\"c99写法，编译器可能会报错： [Error] 'for' loop initial declarations are only allowed in C99 or C11 mode int main(void){ for(int i = 0;i\u003c100;i++) { printf(\"%d\",i); } } 输出0-99 //另一种写法 int main(void){ int i; i = 0; for(;i\u003c100;i++)//i=0可写（）括号里面，i++可写{}大括号里面，效果一样 { printf(\"%d\",i); } 输出0-99 int main(void){ int i; i = 0; for(;i\u003c100;) { i++; printf(\"%d\",i); } } 输出1-100 所以这就是第2，3点的步骤，要记清。 关于for死循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。 #include \u003cstdio.h\u003e int main () { for( ; ; ) { printf(\"该循环会永远执行下去！\\n\"); } return 0; } 当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下。 可以按 Ctrl + C 键终止一个无限循环。 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:6","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"beak和continue beak C 语言中 break 语句有以下两种用法： 当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。 它可用于终止 switch 语句中的一个 case 如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。 continue C 语言中的 continue 语句有点像 break 语句。但它不是强制终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。 对于 for 循环，continue 语句执行后自增语句仍然会执行。对于 while 和 do…while 循环，continue 语句\u0008重新执行条件判断语句。 beak 和 continue的区别 beak是终止本次循环，循环不再继续。continue是跳出当前循环，进入下一次循环，循环还在继续。 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:7","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"goto C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。 在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。 老师虽然说这是个万能的语句，它可以做任何事，事实也是如此，但不建议在程序上使用。哈哈哈。 goto label; .. . label: statement; label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。 它可以往后跳，也可以往前跳。反正就是，最好不要跳，不然腿被打断了都不知道怎么回事。 总结 C语言中常用的编程结构有三种（其它编程语言也是如此），它们分别是： 顺序结构：代码从前往后依次执行，没有任何“拐弯抹角”，不跳过任何一条语句，所有的语句都会被执行到。 选择结构：也叫分支结构。代码会被分成多个部分，程序会根据特定条件（某个表达式的运算结果）来判断到底执行哪一部分。 循环结构：程序会重新执行同一段代码，直到条件不再满足，或者遇到强行跳出语句（break 关键字）。 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:8","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"选择结构 选择结构（分支结构）涉及到的关键字包括 if、else、switch、case、break，还有一个条件运算符? :（这是C语言中唯一的一个三目运算符）。其中，if…else 是最基本的结构，switch…case 和? :都是由 if…else 演化而来，它们都是为了让程序员书写更加方便。 你可以只使用 if，也可以 if…else 配对使用。另外要善于使用 switch…case 和? :，有时候它们看起来更加清爽。 if…else 可以嵌套使用，原则上嵌套的层次（深度）没有限制，但是过多的嵌套层次会让代码结构混乱。 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:9","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":"循环结构 C语言中常用的循环结构有 while 循环和 for 循环，它们都可以用来处理同一个问题，一般可以互相代替。 除了 while 和 for，C语言中还有一个 goto 语句，它也能构成循环结构。不过由于 goto 语句很容易造成代码混乱，维护和阅读困难，饱受诟病，不被推荐，而且 goto 循环完全可以被其他循环取代，所以后来的很多编程语言都取消了 goto 语句，我们也不再讲解。 国内很多大学仍然讲解 goto 语句，但也仅仅是完成教材所设定的课程，goto 语句在实际开发中很难见到。 对于 while 和 do-while 循环，循环体中应包括使循环趋于结束的语句。 对于 while 和 do-while 循环，循环变量的初始化操作应该在 while 和 do-while 语句之前完成，而 for 循环可以在内部实现循环变量的初始化。 for 循环是最常用的循环，它的功能强大，一般都可以代替其他循环。 最后还要注意 break 和 continue 关键字用于循环结构时的区别： break 用来跳出所有循环，循环语句不再有执行的机会； continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。 此外，break 关键字还可以用于跳出 switch…case 语句。所谓“跳出”，是指一旦遇到 break，就不再执行 switch 中的任何语句，包括当前分支中的语句和其他分支中的语句；也就是说，整个 switch 执行结束了，接着会执行整个 switch 后面的代码。 此外，如果循环次数确定，优先使用for循环，不确定用while循环。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-19","objectID":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/:0:10","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 判断、选择与循环","uri":"/19c-%E5%88%A4%E6%96%AD%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF/"},{"categories":["C语言程序设计"],"content":" 1. 什么是static? static 是 C/C++ 中很常用的修饰符，它被用来控制变量的存储方式和可见性。 ","date":"2018-10-18","objectID":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"static 的用法全局变量与局部变量","uri":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"1.1 static 的引入 我们知道在函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义为全局的变量，但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅只受此函数控制）。static 关键字则可以很好的解决这个问题。 ","date":"2018-10-18","objectID":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"static 的用法全局变量与局部变量","uri":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"1.2 静态数据的存储 **全局（静态）存储区：**分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。 在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。 这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main() 函数前的全局数据声明和定义处。 静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的\"尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。 static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。 **优势：**可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。 2. 在 C/C++ 中static的作用 ","date":"2018-10-18","objectID":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"static 的用法全局变量与局部变量","uri":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"2.1 总的来说 （1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。 （2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。 （3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。 （4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。 （5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。 ","date":"2018-10-18","objectID":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"static 的用法全局变量与局部变量","uri":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"2.2 静态变量与普通变量 （1）静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量; （2）未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）； （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。 **优点：**静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。 （1）全局变量和全局静态变量的区别 1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。 2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用 ","date":"2018-10-18","objectID":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"static 的用法全局变量与局部变量","uri":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"2.3 静态局部变量有以下特点： （1）该变量在全局数据区分配内存； （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0； （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。 一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。 看下面的例子： //example: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int k1 = 1; int k2; static int k3 = 2; static int k4; int main() { static int m1 = 2, m2; int i = 1; char*p; char str[10] = \"hello\"; char*q = \"hello\"; p = (char *)malloc(100); free(p); printf(\"栈区-变量地址 i：%p\\n\", \u0026i); printf(\"栈区-变量地址 p：%p\\n\", \u0026p); printf(\"栈区-变量地址 str：%p\\n\", str); printf(\"栈区-变量地址 q：%p\\n\", \u0026q); printf(\"堆区地址-动态申请：%p\\n\", p); printf(\"全局外部有初值 k1：%p\\n\", \u0026k1); printf(\" 外部无初值 k2：%p\\n\", \u0026k2); printf(\"静态外部有初值 k3：%p\\n\", \u0026k3); printf(\" 外静无初值 k4：%p\\n\", \u0026k4); printf(\" 内静态有初值 m1：%p\\n\", \u0026m1); printf(\" 内静态无初值 m2：%p\\n\", \u0026m2); printf(\" 文字常量地址：%p, %s\\n\", q, q); printf(\" 程序区地址：%p\\n\", \u0026main); return 0; } 输出结果： 栈区-变量地址 i：000000000062FE1C 栈区-变量地址 p：000000000062FE10 栈区-变量地址 str：000000000062FE00 栈区-变量地址 q：000000000062FDF8 堆区地址-动态申请：0000000000A313C0 全局外部有初值 k1：0000000000403010 外部无初值 k2：0000000000407A20 静态外部有初值 k3：0000000000403014 外静无初值 k4：0000000000407030 内静态有初值 m1：0000000000403018 内静态无初值 m2：0000000000407034 文字常量地址：0000000000404000, hello 程序区地址：0000000000401530 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-18","objectID":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/:0:5","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"static 的用法全局变量与局部变量","uri":"/18static-%E7%9A%84%E7%94%A8%E6%B3%95%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":" 任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量： 在函数或块内部的局部变量 在所有函数外部的全局变量 在形式参数的函数参数定义中 ","date":"2018-10-17","objectID":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 作用域规则","uri":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"},{"categories":["C语言程序设计"],"content":"局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。 #include \u003cstdio.h\u003e int main () { /* 局部变量声明 */ int a, b; int c; /* 实际初始化 */ a = 10; b = 20; c = a + b; printf (\"value of a = %d, b = %d and c = %d\\n\", a, b, c); return 0; } ","date":"2018-10-17","objectID":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 作用域规则","uri":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"},{"categories":["C语言程序设计"],"content":"全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例： #include \u003cstdio.h\u003e /* 全局变量声明 */ int g; int main () { /* 局部变量声明 */ int a, b; /* 实际初始化 */ a = 10; b = 20; g = a + b; printf (\"value of a = %d, b = %d and g = %d\\n\", a, b, g); return 0; } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。下面是一个实例： 在程序中，局部变量和全局变量的实例 #include \u003cstdio.h\u003e /* 全局变量声明 */ int g = 20; int main () { /* 局部变量声明 */ int g = 10; printf (\"value of g = %d\\n\", g); return 0; } 当上面的代码被编译和执行时，它会产生下列结果 value of g = 10 ","date":"2018-10-17","objectID":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 作用域规则","uri":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"},{"categories":["C语言程序设计"],"content":"形式参数 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。下面是一个实例： #include \u003cstdio.h\u003e /* 全局变量声明 */ int a = 20; int main () { /* 在主函数中的局部变量声明 */ int a = 10; int b = 20; int c = 0; int sum(int, int); printf (\"value of a in main() = %d\\n\", a); c = sum( a, b);//实参，ab以赋值 printf (\"value of c in main() = %d\\n\", c); return 0; } /* 添加两个整数的函数 */ int sum(int a, int b)// 形参，只是声明了，并未赋值 { printf (\"value of a in sum() = %d\\n\", a); printf (\"value of b in sum() = %d\\n\", b); return a + b; } 当上面的代码被编译和执行时，它会产生下列结果： value of a in main() = 10 value of a in sum() = 10 value of b in sum() = 20 value of c in main() = 30 什么是形参与实参？ 从字面上理解，所谓形式参数即只只是声明了一个作为参数的变量，并未直接进行赋值使用，而实际参数则相反。 像上面的例子的注释。 ","date":"2018-10-17","objectID":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 作用域规则","uri":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"},{"categories":["C语言程序设计"],"content":"初始化局部变量和全局变量 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示： | 数据类型 | 初始化默认值 | | ——– | ———— | | int | 0 | | char | ‘\\0’ | | float | 0 | | double | 0 | |pointer |NULL | 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-17","objectID":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 作用域规则","uri":"/17c-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"},{"categories":["C语言程序设计"],"content":" 二进制数的位权是以2为底的幂，如果一个整数 m 是 2 的 n 次幂，那么转换为二进制之后只有最高位为 1，其余位置为 0，再观察 m-1 转换为二进制后的形式以及 m\u0026(m-1) 的结果，例如： 2 --\u003e 0000 0010 1 --\u003e 0000 0001 2\u00261 --\u003e 0000 0010 \u0026 0000 0001 = 0 4 --\u003e 0000 0100 3 --\u003e 0000 0011 4\u00263 --\u003e 0000 0100 \u0026 0000 0011 = 0 8 --\u003e 0000 1000 7 --\u003e 0000 0111 8\u00267 --\u003e 0000 1000 \u0026 0000 0111 = 0 可以看出所有的 1 完美的错过了，根据位与的特点可知 m\u0026(m-1) 的结果为 0。 如果整数 m 不是 2 的 n 次幂，结果会怎样呢？例如 m=9 时： 9 --\u003e 0000 1001 8 --\u003e 0000 1000 9\u00268 --\u003e 0000 1001 \u0026 0000 1000 != 0 利用这一特点，即可判断一个整数是否是2的整数次幂。 int func(int num) { return ((num \u003e 0) \u0026\u0026 ((num \u0026 (num - 1)) == 0));//2的n次幂大于0 } 返回值为 1，则输入的正整数为 2 的整数次幂，返回值为 0 则不是。 对于 2 的幂指数的详细程序 #include \u003cstdio.h\u003e int num; int func(int num) { if ((num\u003e0)\u0026\u0026(num\u0026(num-1))==0) { printf(\"%d是2的整数次幂\",num); } else { printf(\"%d不是2的整数次幂\",num); } return((num\u003e0)\u0026\u0026(num\u0026(num-1))==0); } int main() { printf(\"请输入要查询的数\\n\"); scanf(\"%d\",\u0026num); func(num); } 注意：c语言不能对浮点型进行位运算。 位运算 只能 用于 整型。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-16","objectID":"/16%E5%88%A9%E7%94%A8%E4%BD%8D%E4%B8%8E-%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"利用位与 \u0026 运算，判断一个整数是否是2的整数次幂","uri":"/16%E5%88%A9%E7%94%A8%E4%BD%8D%E4%B8%8E-%E8%BF%90%E7%AE%97%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82/"},{"categories":["C语言程序设计"],"content":" 通常我们交换一个数字，需要引入第三个变量来储存才能进行交换，但利用异或运算可以不需要第三个变量作为中间量。 #include \"stdio.h\"int a = 1; int b = 2; int t; int main(viod){ printf(\"a=%d,b=%d\\n\",a,b); t = a; a = b; b = t; printf(\"a=%d,b=%d\\n\",a,b); } 结果输出： a=1,b=2 a=2,b=1 如果用异或来进行交换： unsigned int a=60; //0011 1100 unsigned int b=13; //0000 1101 a=a^b; //a=a^b=0011 0001 b=a^b; //b=a^b=0011 1100 相当于b1=(a^b)^b a=a^b; //a=a^b=0000 1101 相当于a1=(a^b)^((a^b)^b) #include\u003cstdio.h\u003e int main( ) { unsigned int a=60; //0011 1100 unsigned int b=13; //0000 1101 printf(\"a=%d,b=%d\",a,b); //输出a，b的值 printf(\"\\n\"); a=a^b; //a=a^b=0011 0001 b=a^b; //b=a^b=0011 1100 a=a^b; //a=a^b=0000 1101 printf(\"a=%d,b=%d\",a,b); //输出a，b的值 } 结果输出： a=60,b=13 a=13,b=60 整型负数也可交换 注意：位运算只支持整数运算，不支持浮点型运算。因此上述的方法用在浮点型运算编译不会通过。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-15","objectID":"/15%E5%88%A9%E7%94%A8%E5%BC%82%E6%88%96-%E6%9D%A5%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%80%BC%E8%80%8C%E4%B8%94%E4%B8%8D%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"利用异或 ^ 来交换两个数的值，而且不引入其他变量的方法","uri":"/15%E5%88%A9%E7%94%A8%E5%BC%82%E6%88%96-%E6%9D%A5%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%80%BC%E8%80%8C%E4%B8%94%E4%B8%8D%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["C语言程序设计"],"content":" a++ 是先返回百a的值，再执行++运算。 ++a 是先执行++运算，在返回a的值。 #include \u003cstdio.h\u003e int main(int argc, char **argv) { int a=100; printf(\"a = %d\\n\",a); printf(\"a++ = %d\\n\",a++); printf(\"a = %d\\n\",a); printf(\"++a = %d\\n\",++a); printf(\"a = %d\\n\",a++); return 0; } a = 100 a++ = 100 a = 101 ++a = 102 a = 102 ++a和a++等价的结果一样，但是运算过程不同，a++ 是先使用a的值，然后再对a做加1处理，++a是先对a作加1处理，然后再使用a的值。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-14","objectID":"/14a-%E4%B8%8E-a-%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"a++ 与 ++a 的区别","uri":"/14a-%E4%B8%8E-a-%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["C语言程序设计"],"content":" 我们将 || 和 \u0026\u0026 定义为逻辑运算符，而 | 和 \u0026 定义为位运算符。 \u0026\u0026 如果两个操作数都非零，则条件为真； || 如果两个操作数中有任意一个非零，则条件为真。 \u0026 按位与操作，按二进制位进行\"与\"运算。 | 按位或运算符，按二进制位进行\"或\"运算 那么，问题来了，在判断语句中，用 | 还是 ||，\u0026 还是 \u0026\u0026？ 判断语句中为布尔类型，值只有 true 和 false（如果变量值为 0 就是 false，否则为 true） 举个例子，a=1 b=2 所以 a\u003e0 这个值为true b\u003e1 这个值为true b\u003e2 这个值为 false 如 if(a\u003e0\u0026b\u003e1) 我们可以得出 if(true\u0026true)，条件成立（true不为0，所以true\u0026true不为0） 如 if(a\u003e0\u0026\u0026b\u003e1) 我们可以得出 if(true\u0026\u0026true),条件成立（\u0026\u0026两边操作数都非零，所以条件成立） 如 if(b\u003e2\u0026a\u003e0) 我们可以得出 if(false\u0026true)，条件不成立（false为0，false\u0026true为0，条件不成立） 如 if(b\u003e2\u0026\u0026a\u003e0) 我们可以得出 if(false\u0026\u0026a\u003e0)，条件不成立（\u0026\u0026左侧为false，\u0026\u0026运算到此结束，条件不成立） 可以看出 \u0026 和 \u0026\u0026 在判断语句中都可以实现“和”这个功能，不过区别在于 \u0026 两边都运算，而 \u0026\u0026 先算 \u0026\u0026 左侧，若左侧为 false 那么右侧就不运算了。因此从效率上来说，判断语句中推荐使用 \u0026\u0026（换句话就是逻辑运算就老老实实用逻辑运算符，不然它为啥叫逻辑运算符呢？） 而 | 和 || 的比较与上类似，不做赘述。 总结：从效率上来说，判断语句中推荐使用 \u0026\u0026 ||逻辑运算。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-13","objectID":"/13-l%E5%92%8Cll-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"| 和 ||，\u0026 和 \u0026\u0026 的区别","uri":"/13-l%E5%92%8Cll-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["C语言程序设计"],"content":" 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 ","date":"2018-10-12","objectID":"/12c-%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 运算符","uri":"/12c-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C语言程序设计"],"content":"算术运算符 运算符 描述 + 把两个操作数相加 - 从第一个操作数中减去第二个操作数 * 把两个操作数相乘 / 分子除以分母 % 取模运算符，整除后的余数 ++ 自增运算符，整数值增加 1 – 自增运算符，整数值减少 1 关系运算符 A= 0 B =1 | 运算符 | 描述 | 实例 | | —— | ———————————————————— | ————— | | == | 检查两个操作数的值是否相等，如果相等则条件为真。 | (A == B) 为假。 | | != | 检查两个操作数的值是否相等，如果不相等则条件为真。 | (A != B) 为真。 | | \u003e | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 | (A \u003e B) 为假。 | | \u003e\u003c | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 | (A \u003c B) 为真。 | | \u003e= | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A \u003e= B) 为假。 | | \u003c= | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A \u003c= B) 为真。 | 逻辑运算符 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A \u0026\u0026 B) 为假。 ll 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A ll B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A \u0026\u0026 B) 为真。 位运算符 \u0026 按位与操作，按二进制位进行\"与\"运算。运算规则： 0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; | 按位或运算符，按二进制位进行\"或\"运算。运算规则： 0|0=0; 0|1=1; 1|0=1; 1|1=1; ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则： 0^0=0; 0^1=1; 1^0=1; 1^1=0; ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则： ~1=0; ~0=1; « 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A = 6 A的二进制为：0110 A \u003c\u003c 2 将得到 1000， 即 A = 8 » 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A = 6 A的二进制为：0110 A \u003e\u003e 2 将得到 0001， 即 A = 1 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 »= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 l= 按位或且赋值运算符 C l= 2 等同于 C = C l 2 杂项运算符 ↦ sizeof \u0026 三元 运算符 描述 实例 sizeof() 返回变量的大小。 sizeof(a) 将返回 4，其中 a 是整数。 \u0026 返回变量的地址。 \u0026a; 将给出变量的实际地址。 * 指向一个变量。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则值为 X : 否则值为 Y #include \u003cstdio.h\u003e int main() { int a = 10; short b; /* 三元运算符实例 */ b = (a == 1) ? 20: 30; //先判断？左边a是否等于1，显然否，则返回的值是30，然后赋值给b。下同 printf( \"b 的值是 %d\\n\", b ); b = (a == 10) ? 20: 30; printf( \"b 的值是 %d\\n\", b ); } b 的值是 30 b 的值是 20 ","date":"2018-10-12","objectID":"/12c-%E8%BF%90%E7%AE%97%E7%AC%A6/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 运算符","uri":"/12c-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C语言程序设计"],"content":"C 中的运算符优先级 同一优先级的运算符，运算次序由结合方向所决定。 简单记就是：！ \u003e 算术运算符 \u003e 关系运算符 \u003e \u0026\u0026 \u003e || \u003e 赋值运算符 初等运算符\u003e单目运算符\u003e算术运算符\u003e关系运算符\u003e逻辑运算符\u003e条件运算符\u003e赋值运算符 初等运算符有：（）、[ ]、-\u003e、. (后两者均为结构体成员运算符)； 单目运算符有：！、~、++、--、sizeof、\u0026、*； 算术运算符有：*、/、+、-、\u003c\u003c、\u003e\u003e; 关系运算符有：\u003c、\u003c=、\u003e、\u003e=、==、!=、\u0026、^、|；(此栏排列仍有优先级顺序哦); 逻辑运算符有：\u0026\u0026、||； 条件运算符有：？：（即三目运算符）; 赋值运算符有：=、+=、-=、*=、/=、%=、\u003e\u003e=、\u003c\u003c=；等 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-12","objectID":"/12c-%E8%BF%90%E7%AE%97%E7%AC%A6/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 运算符","uri":"/12c-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C语言程序设计"],"content":" 存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。 auto 是局部变量的默认存储类, 限定变量只能在函数内部使用； register 代表了寄存器变量，不在内存中使用； static是全局变量的默认存储类,表示变量在程序生命周期内可见； extern 表示全局变量，即对程序内所有文件可见， ","date":"2018-10-11","objectID":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C语言程序设计"],"content":"auto auto 存储类是所有局部变量默认的存储类。 auto 只能用在函数内，即 auto 只能修饰局部变量。** #include \u003cstdio.h\u003e int main(void) { auto int i = 9; /* 声明局部变量的关键字是 auto; 因可以省略, 几乎没人使用 */ printf(\"%d\\n\", i); getchar(); return 0; } ","date":"2018-10-11","objectID":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C语言程序设计"],"content":"Register register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘\u0026’ 运算符（因为它没有内存位置）。 动态和静态变量都是存放在内存中，程序中遇到该值时用控制器发指令将变量的值送到运算器中，需要存数再保存到内存中。如果频繁使用一个变量，比如一个函数体内的多次循环每次都引用该局部变量，我们则可以把局部变量的值放到CPU的寄存器中，叫寄存器变量。不需要多次到内存中存取提高效率。但是只能局部自动变量和形参可以做寄存器变量。在函数调用时占用一些寄存器，函数结束时释放。不同系统对register要求也不一样，比如对 定义register变量个数，数据类型等限制，有的默认为自动变量处理。所以在程序一般也不用。 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 #include \u003cstdio.h\u003e#include \u003ctime.h\u003e #define TIME 1000000000 int m, n = TIME; /* 全局变量 */ int main(void) { time_t start, stop; register int a, b = TIME; /* 寄存器变量 */ int x, y = TIME; /* 一般变量 */ time(\u0026start); for (a = 0; a \u003c b; a++); time(\u0026stop); printf(\"寄存器变量用时: %ld 秒\\n\", stop - start); time(\u0026start); for (x = 0; x \u003c y; x++); time(\u0026stop); printf(\"一般变量用时: %ld 秒\\n\", stop - start); time(\u0026start); for (m = 0; m \u003c n; m++); time(\u0026stop); printf(\"全局变量用时: %ld 秒\\n\", stop - start); return 0; } 输出结果： 寄存器变量用时: 1 秒 一般变量用时: 8 秒 全局变量用时: 9 秒 ","date":"2018-10-11","objectID":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C语言程序设计"],"content":"static static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。 实例 #include \u003cstdio.h\u003e /* 函数声明 */ void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main() { while (count--) { func1(); } return 0; } void func1(void) { /* 'thingy' 是 'func1' 的局部变量 - 只初始化一次 * 每次调用函数 'func1' 'thingy' 值不会被重置。 */ static int thingy=5; thingy++; printf(\" thingy 为 %d ， count 为 %d\\n\", thingy, count); } 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。 在 C 语言中，static 可以用来修饰局部变量，全局变量以及函数。在不同的情况下 static 的作用不尽相同。 1)修饰局部变量 一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。 在用static修饰局部变量后，该变量只在初次运行时进行初始化工作，且只进行一次。 #include\u003cstdio.h\u003e void fun() { static int a=1; a++; printf(\"%d\\n\",a); } int main(void) { fun(); fun(); return 0; } 程序执行结果为: 2 3 说明在第二次调用fun()函数时，a的值为2，并且没有进行初始化赋值，直接进行自增运算，所以得到的结果为3. 对于静态局部变量如果没有进行初始化的话，对于整形变量系统会自动对其赋值为0，对于字符数组，会自动赋值为’\\0’. 2)修饰全局变量 对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。 //有file1.c int a=1; file2.c #include\u003cstdio.h\u003e extern int a; int main(void) { printf(\"%d\\\",a); return 0; } 则执行结果为 1 但是如果在 file1.c 中把 int a=1 改为 static int a=1; 那么在file2.c是无法访问到变量a的。原因在于用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。 3)修饰函数 用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。 sratic只初始化一次 如果实在函数内部定义的，那么这个变量只初始化一次，即使再次调用这个函数，这个static变量也不会再次初始化 ， 这个变量的取值就会一直保存着，也就是说，当你再次调用这个函数的时候，里面用到这个static变量时，就会发现，它还是上一次函数调用时的结果。 #include \u003cstdio.h\u003e void varfunc(void) { int var=0; static int static_var=0; printf(\"var equal: %d\\n\",var); printf(\"static_var equal: %d\\n\",static_var); printf(\"\"); var++; static_var++; } int main(int argc, char *argv[]) { int i; for(i=0;i\u003c3;i++) varfunc(); return 0; } 运行结果如下： var equal: 0 static_var equal: 0 var equal: 0 static_var equal: 1 var equal: 0 static_var equal: 2 ","date":"2018-10-11","objectID":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C语言程序设计"],"content":"extern extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 main.c #include \u003cstdio.h\u003e int count ; extern void write_extern(); int main() { count = 5; write_extern(); } support.c #include \u003cstdio.h\u003e extern int count; void write_extern(void) { printf(\"count is %d\\n\", count); } 编译结果 count is 5 第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。 因此count是作为全局变量使用。 ","date":"2018-10-11","objectID":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C语言程序设计"],"content":"C 语言中全局变量、局部变量、静态全局变量、静态局部变量的区别 从作用域看： 1、全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。 2、静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。 3、局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 4、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。 从分配内存空间看： 1、全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间 2、全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 1)静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。 2)变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。 Tips: A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度； B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度； C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见； D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带\"内部存储器\"功能的的函数) E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-11","objectID":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/:0:5","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/11c-%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C语言程序设计"],"content":"定义 边缘效应是指在两个或两个以上不同性质的生态系统交互作用处，由于某些生态因子(物质、能量、信息、时机或地域)或系统属性的差异和协合作用而引起系统某些组分及行为的较大变化。 这个定义晦涩难懂！ ","date":"2018-10-10","objectID":"/10#define%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%88%E5%BA%94/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"#define引起的“边缘效应”","uri":"/10#define%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%88%E5%BA%94/"},{"categories":["C语言程序设计"],"content":"为何#define会引起边缘效应？ #define N 2+3 这时 N 的值是 5。 #include \u003cstdio.h\u003e#define N 2+3 //正确写法 #define N (2+3) int main(){ double a ; a = (float)N/(float)2; printf(\"a 的值为 : %.2f\", a); return 0; } 在编译时我们预想 a=2.5，实际打印结果是 3.5 原因是在预处理阶段，编译器将 a=N/2 处理成 a=2+3/2，这就是 define 宏的边缘效应。 ","date":"2018-10-10","objectID":"/10#define%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%88%E5%BA%94/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"#define引起的“边缘效应”","uri":"/10#define%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%88%E5%BA%94/"},{"categories":["C语言程序设计"],"content":"如何解决？ 所以我们应该写成 #define N (2+3)。所以要用两个个括号括起来，就不怕边界效应了。 利用define进行宏定义的时候，需要格外注意边缘效，有时一不小心就会造成严重的后果。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-10","objectID":"/10#define%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%88%E5%BA%94/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"#define引起的“边缘效应”","uri":"/10#define%E5%BC%95%E8%B5%B7%E7%9A%84%E8%BE%B9%E7%BC%98%E6%95%88%E5%BA%94/"},{"categories":["C语言程序设计"],"content":" define是预编译指令，在预编译的时候仅仅进行字符替换，预编译后符号常量就不存在了，例如define PI 3.1415926 ，编译以后就不存在PI了，所有的PI都被换成了3.1415926。而且PI没有存储单元。而常变量const变量要占用存储单元，有变量值，只是值不能改，它有符号变量的优点，而且比较方便。 #define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存 ","date":"2018-10-09","objectID":"/9%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"定义常量#define和const的区别","uri":"/9%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["C语言程序设计"],"content":"两者的区别 (1) 编译器处理方式不同 #define 宏是在预处理阶段展开。 const 常量是编译运行阶段使用。 (2) 类型和安全检查不同 #define 宏没有类型，不做任何类型检查，仅仅是展开，仅仅是简单的字符串替换。 const 常量有具体的类型，在编译阶段会执行类型检查。 简单的字符串替换会导致边界效应 (3) 存储方式不同 #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。） const常量会在内存中分配(可以是堆中也可以是栈中)。 define预处理后占用代码空间，而const占用数据段空间。 (4) const 可以节省空间，避免不必要的内存分配。 例如： #define NUM 3.14159 //常量宏 const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ...... double i = Num; //此时为Pi分配内存，以后不再分配！ double I= NUM; //编译期间进行宏替换，分配内存 double j = Num; //没有内存分配 double J = NUM; //再进行宏替换，又一次分配内存！ const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。 (5) const提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 (6) 宏替换只作替换不做计算 宏替换只作替换，不做计算，不做表达式求解;宏预编译时就替换了，程序运行时，并不分配内存。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-09","objectID":"/9%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"定义常量#define和const的区别","uri":"/9%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["C语言程序设计"],"content":" 常量是固定值，在程序执行期间不会改变。一旦定义了一个常量，在程序执行中是不可被更改的，这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 常量的类型 ","date":"2018-10-08","objectID":"/8c-%E5%B8%B8%E9%87%8F/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 常量","uri":"/8c-%E5%B8%B8%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写。U 和 L 的顺序任意（无符号长整型）。 整数常量的实例： 212 /* 合法的 */ 215u /* 合法的 */ 0xFeeL /* 合法的 */ 078 /* 非法的：8 不是八进制的数字 */ 032UU /* 非法的：不能重复后缀 */ 各种类型的整数常量的实例： 85 /* 十进制 */ 0213 /* 八进制 */ 0x4b /* 十六进制 */ 30 /* 整数 */ 30u /* 无符号整数 */ 30l /* 长整数 */ 30ul /* 无符号长整数 */ ","date":"2018-10-08","objectID":"/8c-%E5%B8%B8%E9%87%8F/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 常量","uri":"/8c-%E5%B8%B8%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 几个浮点常量的实例： 3.14159 /* 合法的 */ 314159E-5L /* 合法的 */ 510E /* 非法的：不完整的指数 */ 210f /* 非法的：没有小数或指数 */ .e55 /* 非法的：缺少整数或分数 */ ","date":"2018-10-08","objectID":"/8c-%E5%B8%B8%E9%87%8F/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 常量","uri":"/8c-%E5%B8%B8%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"字符常量 字符常量是括在单引号中，例如，‘x’ 可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： \\\\ \\ 字符 \\' ' 字符 \\\" \" 字符 \\? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 ","date":"2018-10-08","objectID":"/8c-%E5%B8%B8%E9%87%8F/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 常量","uri":"/8c-%E5%B8%B8%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"字符串常量 字符串字面值或常量是括在双引号 \"” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 如何定义常量 在 C 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 ","date":"2018-10-08","objectID":"/8c-%E5%B8%B8%E9%87%8F/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 常量","uri":"/8c-%E5%B8%B8%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"#define 预处理器 #define 宏定义 #define \u003c常量名\u003e \u003cvalue\u003e #define N 3 // 定义内了一个常量为3的宏N，在程序中N就代表3 ","date":"2018-10-08","objectID":"/8c-%E5%B8%B8%E9%87%8F/:0:5","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 常量","uri":"/8c-%E5%B8%B8%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"const 关键字 const type \u003c常量名\u003e = value; int a = 2; // 定义了一个int型变量，并赋容值为2，其实这是用变量来定义常量 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-08","objectID":"/8c-%E5%B8%B8%E9%87%8F/:0:6","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 常量","uri":"/8c-%E5%B8%B8%E9%87%8F/"},{"categories":["C语言程序设计"],"content":" 变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型： char 通常是一个字节（八位）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 void 表示类型的缺失。 C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等,后面会学到。 ","date":"2018-10-07","objectID":"/7c-%E5%8F%98%E9%87%8F/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 变量","uri":"/7c-%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"变量的定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。在程序中，变量有且仅有一个定义。 ","date":"2018-10-07","objectID":"/7c-%E5%8F%98%E9%87%8F/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 变量","uri":"/7c-%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"变量的声明 变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 变量的声明有两种情况： 1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。 2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。 注意：除非有extern关键字，否则都是变量的定义。 extern int i; //声明，不是定义 int i; //声明，也是定义 ","date":"2018-10-07","objectID":"/7c-%E5%8F%98%E9%87%8F/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 变量","uri":"/7c-%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"C 中的左值（Lvalues）和右值（Rvalues） C 中有两种类型的表达式： 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句： int g = 20; 但是下面这个就不是一个有效的语句，会生成编译时错误： 10 = 20; 当需要保存数据的时候，需要lvalues。 当需要读取数据的时候，需要rvalues。 lvalues 和 rvalues 角色的相互转换 1、 根据表达式的上下文情况，lvalues 在需要 rvalues 的地方会自动转换为 rvalues。例如: int n; int m; m = n+2; // 这个表达式里 n 是 rvalues 2、 rvalues 永远不能转换为 lvalues ","date":"2018-10-07","objectID":"/7c-%E5%8F%98%E9%87%8F/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 变量","uri":"/7c-%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"变量定义和变量声明的区别 变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。 变量声明：用于向程序表明变量的类型和名字。 定义也是声明，extern 声明不是定义。 定义也是声明：当定义变量时我们声明了它的类型和名字，extern 声明不是定义：通过使用 extern 关键字声明变量名而不定义它。 变量在使用前就要被定义或者声明。 在一个程序中，变量只能定义一次，却可以声明多次。 定义分配存储空间，而声明不会。 ","date":"2018-10-07","objectID":"/7c-%E5%8F%98%E9%87%8F/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 变量","uri":"/7c-%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":"全局变量和局部变量在内存中的区别 全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 C语言经过编译之后将内存分为以下几个区域： （1）栈（stack）：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。 （2）堆（heap）：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。 （3）全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。 （4）文字常量区：存放常量字符串。程序结束后由系统释放。 （5）程序代码区：存放程序的二进制代码。 显然，C语言中的全局变量和局部变量在内存中是有区别的。C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-07","objectID":"/7c-%E5%8F%98%E9%87%8F/:0:5","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 变量","uri":"/7c-%E5%8F%98%E9%87%8F/"},{"categories":["C语言程序设计"],"content":" 在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。 C 中的类型可分为以下几种: 1 基本类型： 它们是算术类型，包括两种类型：整数类型和浮点类型。 2 枚举类型： 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 3 void 类型： 类型说明符 void 表明没有可用的值。 4 派生类型： 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。 ","date":"2018-10-06","objectID":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C语言程序设计"],"content":"整数类型 编译器可以根据自身硬件来选择百合适的大小，但是需要满足约束：short和int型至少为16位，long型至少为32位，并且度short型长度不能超过int型，而int型不能超过long型。这即是说各个类型的变量长度是由编译器来决定的，而当前主流的编译器中一般是32位机器知和64位机器中int型都是4个字节。 为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。下面的实例演示了获取 int 类型的大小： #include \u003cstdio.h\u003e#include \u003climits.h\u003e int main() { printf(\"int 存储大小 : %lu \\n\", sizeof(int)); return 0; } \u003e\u003e\u003e int 存储大小 : 4 ","date":"2018-10-06","objectID":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C语言程序设计"],"content":"浮点类型 下表列出了关于标准浮点类型的存储大小、值范围和精度的细节： ","date":"2018-10-06","objectID":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C语言程序设计"],"content":"void 类型 void 类型指定没有可用的值。它通常用于以下三种情况下： 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 ","date":"2018-10-06","objectID":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C语言程序设计"],"content":"其它： 常用基本数据类型占用空间（64位机器为例） char ： 1个字节 int ：4个字节 float：4个字节 double：8个字节 基本类型书写 默认为10进制 ，10 ，20 以0开头为8进制，045，021 以0b开头为2进制，0b11101101 以0x开头为16进制，0x21458adf 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-06","objectID":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C语言模板","uri":"/6c-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C语言程序设计"],"content":"C 的令牌（Tokens） C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌： printf(\"Hello, World! \\n\"); 这五个令牌分别是： printf ( \"Hello, World! \\n\" ) ; 分号 ; C 语言有两种注释方式：单行注释（//）和多行注释（/* */） //这是单行注释 /*这是 多行 注释*/ 不能在注释内嵌套注释，注释也不能出现在字符串或字符值中。 标识符 C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，OldHuang 和 oldhuang 是两个不同的标识符。 ","date":"2018-10-05","objectID":"/5c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 基本语法","uri":"/5c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C语言程序设计"],"content":"关键字 下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。 关键字 说明 auto 声明自动变量 break 跳出当前循环 case 开关语句分支 char 声明字符型变量或函数返回值类型 const 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 continue结束当前循环，开始下一轮循环 default 开关语句中的\"其它\"分支 do 循环语句的循环体 double 声明双精度浮点型变量或函数返回值类型 else 条件语句否定分支（与 if 连用） enum 声明枚举类型 extern 声明变量或函数是在其它文件或本文件的其他位置定义 float 声明浮点型变量或函数返回值类型 for 一种循环语句 goto 无条件跳转语句 if 条件语句 int 声明整型变量或函数 long 声明长整型变量或函数返回值类型 register声明寄存器变量 return 子程序返回语句（可以带参数，也可不带参数） short 声明短整型变量或函数 signed 声明有符号类型变量或函数 sizeof 计算数据类型或变量长度（即所占字节数） static 声明静态变量 struct 声明结构体类型 switch 用于开关语句 typedef 用以给数据类型取别名 unsigned声明无符号类型变量或函数 union 声明共用体类型 void 声明函数无返回值或无参数，声明无类型指针 volatile说明变量在程序执行中可被隐含地改变 while 循环语句的循环条件 C 中的空格 只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。 空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-05","objectID":"/5c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 基本语法","uri":"/5c-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C语言程序设计"],"content":" C 程序主要包括以下部分： 预处理器指令 函数 变量 语句 \u0026 表达式 注释 #include \u003cstdio.h\u003e /* 我的第一个 C 程序 */ int main() { printf(\"Hello, World! \\n\"); return 0; } 1、程序的第一行 #include \u003cstdio.h\u003e 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。 2、 /…/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。 3、 int main() 是主函数，程序从这里开始执行。 4、 printf(…) 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!\"。 5、 return 0; 终止 main() 函数，并返回值 0。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-04","objectID":"/4c-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"C 程序结构","uri":"/4c-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"},{"categories":["C语言程序设计"],"content":"二进制、八进制和十六进制向十进制转换 二进制、八进制和十六进制向十进制转换都非常容易，就是“按权相加”。所谓“权”，也即“位权”。 假设当前数字是 N 进制，那么： 对于整数部分，从右往左看，第 i 位的位权等于N^(i-1) 对于小数部分，恰好相反，要从左往右看，第 j 位的位权为N^-j。 ","date":"2018-10-03","objectID":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"2进制8进制10进制16进制之间的转换","uri":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/"},{"categories":["C语言程序设计"],"content":"将十进制转换为二进制、八进制、十六进制 将十进制转换为其它进制时比较复杂，整数部分和小数部分的算法不一样。 ####　1) 整数部分 十进制整数转换为 N 进制整数采用“除 N 取余，逆序排列”法。具体做法是： 将 N 作为除数，用十进制整数除以 N，可以得到一个商和余数； 保留余数，用商继续除以 N，又得到一个新的商和余数； 仍然保留余数，用商继续除以 N，还会得到一个新的商和余数； …… 如此反复进行，每次都保留余数，用商接着除以 N，直到商为 0 时为止。 把先得到的余数作为 N 进制数的低位数字，后得到的余数作为 N 进制数的高位数字，依次排列起来，就得到了 N 进制数字。 十进制数字 36926 转换成八进制的过程： 十进制数字 42 转换成二进制的过程： 2) 小数部分 十进制小数转换成 N 进制小数采用“乘 N 取整，顺序排列”法。具体做法是： 用 N 乘以十进制小数，可以得到一个积，这个积包含了整数部分和小数部分； 将积的整数部分取出，再用 N 乘以余下的小数部分，又得到一个新的积； 再将积的整数部分取出，继续用 N 乘以余下的小数部分； …… 如此反复进行，每次都取出整数部分，用 N 接着乘以小数部分，直到积中的小数部分为 0，或者达到所要求的精度为止。 把取出的整数部分按顺序排列起来，先取出的整数作为 N 进制小数的高位数字，后取出的整数作为低位数字，这样就得到了 N 进制小数. 十进制小数 0.930908203125 转换成八进制小数的过程： 0.6875 转换成二进制小数的过程: ","date":"2018-10-03","objectID":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"2进制8进制10进制16进制之间的转换","uri":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/"},{"categories":["C语言程序设计"],"content":"前17个十进制整数与二进制、八进制、十六进制的对应关系 ","date":"2018-10-03","objectID":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/:0:3","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"2进制8进制10进制16进制之间的转换","uri":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/"},{"categories":["C语言程序设计"],"content":"神奇的8421法 当我学完数电之后，发现进制的转化可以更加简单了。比如（1100 1011）二进制转化为八进制就是（313）8，转化为十进制就是128+64+8+2+1=（203）10，转化为十六进制就是（CB）16 原理 十进制由于不是2的整数次方得出的进制，因此需要特别注意一下。这种方法可以推广到多进制，比如32进制，就变成了16 8 4 2 1。只是日常生活中我们用8421已经足以了。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-03","objectID":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/:0:4","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"2进制8进制10进制16进制之间的转换","uri":"/3%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%E4%BA%8C%E5%85%AB%E5%8D%81%E5%8D%81%E5%85%AD/"},{"categories":["C语言程序设计"],"content":" 我们平时使用的数字都是由 0~9 共十个数字组成的，例如 1、9、10、297、952 等，一个数字最多能表示九，如果要表示十、十一、二十九、一百等，就需要多个数字组合起来。 例如表示 5+8 的结果，一个数字不够，只能”进位“，用 13 来表示；这时”进一位“相当于十，”进两位“相当于二十。 因为逢十进一（满十进一），也因为只有 0~9 共十个数字，所以叫做十进制（Decimalism）。十进制是在人类社会发展过程中自然形成的，它符合人们的思维习惯，例如人类有十根手指，也有十根脚趾。 进制也就是进位制。进行加法运算时逢X进一（满X进一），进行减法运算时借一当X，这就是X进制，这种进制也就包含X个数字，基数为X。十进制有 0~9 共10个数字，基数为10，在加减法运算中，逢十进一，借一当十。 ","date":"2018-10-02","objectID":"/2%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%88%B6/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"什么是进制？","uri":"/2%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%88%B6/"},{"categories":["C语言程序设计"],"content":"二进制 我们不妨将思维拓展一下，既然可以用 0~9 共十个数字来表示数值，那么也可以用0、1两个数字来表示数值，这就是二进制（Binary）。例如，数字 0、1、10、111、100、1000001 都是有效的二进制。 在计算机内部，数据都是以二进制的形式存储的，二进制是学习编程必须掌握的基础。本节我们先讲解二进制的概念，下节讲解数据在内存中的存储，让大家学以致用。 二进制加减法和十进制加减法的思想是类似的： 对于十进制，进行加法运算时逢十进一，进行减法运算时借一当十； 对于二进制，进行加法运算时逢二进一，进行减法运算时借一当二。 下面两张示意图详细演示了二进制加减法的运算过程。 1) 二进制加法： 1+0=1、1+1=10、11+10=101、111+111=1110 2) 二进制减法： 1-0=1、10-1=1、101-11=10、1100-111=101 ","date":"2018-10-02","objectID":"/2%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%88%B6/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"什么是进制？","uri":"/2%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%88%B6/"},{"categories":["C语言程序设计"],"content":"八进制 除了二进制，C语言还会使用到八进制。 八进制有 0~7 共8个数字，基数为8，加法运算时逢八进一，减法运算时借一当八。例如，数字 0、1、5、7、14、733、67001、25430 都是有效的八进制。 下面两张图详细演示了八进制加减法的运算过程。 1) 八进制加法： 3+4=7、5+6=13、75+42=137、2427+567=3216 2) 八进制减法： 6-4=2、52-27=23、307-141=146、7430-1451=5757 十六进制 除了二进制和八进制，十六进制也经常使用，甚至比八进制还要频繁。 十六进制中，用A来表示10，B表示11，C表示12，D表示13，E表示14，F表示15，因此有 0~F 共16个数字，基数为16，加法运算时逢16进1，减法运算时借1当16。例如，数字 0、1、6、9、A、D、F、419、EA32、80A3、BC00 都是有效的十六进制。 注意，十六进制中的字母不区分大小写，ABCDEF 也可以写作 abcdef。 下面两张图详细演示了十六进制加减法的运算过程。 1) 十六进制加法： 6+7=D、18+BA=D2、595+792=D27、2F87+F8A=3F11 2) 十六进制减法： D-3=A、52-2F=23、E07-141=CC6、7CA0-1CB1=5FEF 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-02","objectID":"/2%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%88%B6/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"什么是进制？","uri":"/2%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%88%B6/"},{"categories":["C语言程序设计"],"content":" 我们每天都在使用计算机，无论是桌面计算机还是智能手机，其实都是某种形式的计算机。要用计算机做某件事情，就需要使用某个具体的应用软件。这些应用软件都是用某种编程语言写出来，告诉计算机要如何为我们做事情的。编程语言就是用来描述我们要计算机如何做事情的语言。 计算机和人脑完全不一样，计算机有自己的思维方式和行为习惯。所以有的事情人类很容易就做到了，计算机可能会很困难；而有的事情人类不擅长或者不乐意做，计算机却可能会很容易实现。学习编程就需要了解计算机做事情的方式方法，学会用计算机的方式来想问题，这就叫做计算思维。 在我没上大学之前，我就听说过有一个职业，叫做程序员。程序员也很幽默，喜欢自嘲，经常说自己的工作辛苦，地位低，像农民一样，所以称自己是”码农“，就是写代码的农民。也有人自嘲称是”程序猿“。 对于大部分程序员，C语言是学习编程的第一门语言，很少有不了解C的程序员。 C语言除了能让你了解编程的相关概念，带你走进编程的大门，还能让你明白程序的运行原理，比如，计算机的各个部件是如何交互的，程序在内存中是一种怎样的状态，操作系统和用户程序之间有着怎样的“爱恨情仇”，这些底层知识决定了你的发展高度，也决定了你的职业生涯。 如果你希望成为出类拔萃的人才，而不仅仅是码农，这么这些知识就是不可逾越的。也只有学习C语言，才能更好地了解它们。有了足够的基础，以后学习其他语言，会触类旁通，很快上手，7 天了解一门新语言不是神话。 C语言概念少，词汇少，包含了基本的编程元素，后来的很多语言（C++、Java等）都参考了C语言，说C语言是现代编程语言的开山鼻祖毫不夸张，它改变了编程世界。 正是由于C语言的简单，对初学者来说，学习成本小，时间短，结合本教程，能够快速掌握编程技术。 ","date":"2018-10-01","objectID":"/1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFc%E8%AF%AD%E8%A8%80/:0:0","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"为什么是C语言？","uri":"/1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFc%E8%AF%AD%E8%A8%80/"},{"categories":["C语言程序设计"],"content":"C语言的定义 C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。C语言是仅产生少量的机器语言以及不需要任何运行环境支持便能运行的高效率程序设计语言。尽管C语言提供了许多低级处理的功能，但仍然保持着跨平台的特性，以一个标准规格写出的C语言程序可在包括类似嵌入式处理器以及超级计算机等作业平台的许多计算机平台上进行编译。 ","date":"2018-10-01","objectID":"/1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFc%E8%AF%AD%E8%A8%80/:0:1","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"为什么是C语言？","uri":"/1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFc%E8%AF%AD%E8%A8%80/"},{"categories":["C语言程序设计"],"content":"为什么是C 也许是机缘巧合，C语言出现后不久，计算机产业开始爆发，计算机硬件越来越小型化，越来越便宜，逐渐进入政府机构，进入普通家庭，C语言成了编程的主力军，获得了前所未有的成功，操作系统、常用软件、硬件驱动、底层组件、核心算法、数据库、小游戏等都使用C语言开发。 C语言在计算机产业大爆发阶段被万人膜拜，无疑会成为整个软件产业的基础，拥有核心地位。 软件行业的很多细分学科都是基于C语言的，学习数据结构、算法、操作系统、编译原理等都离不开C语言，所以大学将C语言作为一门公共课程，计算机相关专业的同学都要学习。 C语言被誉为“上帝语言”，它不但奠定了软件产业的基础，还创造了很多其它语言，例如： PHP、Python 等都是用C语言开发出来的，虽然平时做项目的时候看不到C语言的影子，但是如果想深入学习 PHP 和 Python，那就要有C语言基础了。 C++ 和 Objective-C 干脆在C语言的基础上直接进行扩展，增加一些新功能后变成了新的语言，所以学习 C++ 和 Objective-C 之前也要先学习C语言 关于文章时间 C语言的学习时间为2018年大一第一学期，笔记的整理时间是2020年春节期间，具体是什么时候写的已经忘了（模糊记忆是那年的国庆 ），因此为了自己更好的管理文章。统一起点为2018年的10月1日起。整理期间又复习了一遍c语言，发现了很多以前没掌握的知识，内容有新增也有删减。文章更新时间即是复习C语言整理笔记的时间。 参考资料 程序设计入门–C翁恺 《c语言程序设计》–谭浩强 《C Primer Plus》–Stephen Prata C语言中文网 C语言教程|菜鸟教程 ","date":"2018-10-01","objectID":"/1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFc%E8%AF%AD%E8%A8%80/:0:2","tags":["C语言程序设计","C语言程序设计基础","hello word"],"title":"为什么是C语言？","uri":"/1%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFc%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"计算机组成原理 STM32F103资料（洋桃开发版)提取码：77ru 晋中STM32资料 提取码: tbin ","date":"0001-01-01","objectID":"/file/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:0","tags":null,"title":"参考资料","uri":"/file/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":null,"content":"DEV C++ ","date":"0001-01-01","objectID":"/file/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/:0:0","tags":null,"title":"开发工具/软件","uri":"/file/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"}]